/*!
 * @pixi-spine/runtime-4.1 - v4.0.3
 * Compiled Thu, 19 Jan 2023 18:41:37 UTC
 *
 * @pixi-spine/runtime-4.1 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine41=function(X,f,at){"use strict";class Lt{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const Ye=class extends Lt{constructor(h){super(h),this.id=Ye.nextID++,this.bones=null,this.vertices=[],this.worldVerticesLength=0,this.timelineAttachment=this}computeWorldVerticesOld(h,t){this.computeWorldVertices(h,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(h,t,s,e,i,r){s=i+(s>>1)*r;const d=h.bone.skeleton,l=h.deform;let n=this.vertices;const a=this.bones;if(!a){l.length>0&&(n=l);const g=h.bone.matrix,u=g.tx,p=g.ty,y=g.a,S=g.c,x=g.b,k=g.d;for(let w=t,M=i;M<s;w+=2,M+=r){const B=n[w],A=n[w+1];e[M]=B*y+A*S+u,e[M+1]=B*x+A*k+p}return}let o=0,c=0;for(let g=0;g<t;g+=2){const u=a[o];o+=u+1,c+=u}const m=d.bones;if(l.length==0)for(let g=i,u=c*3;g<s;g+=r){let p=0,y=0,S=a[o++];for(S+=o;o<S;o++,u+=3){const x=m[a[o]].matrix,k=n[u],w=n[u+1],M=n[u+2];p+=(k*x.a+w*x.c+x.tx)*M,y+=(k*x.b+w*x.d+x.ty)*M}e[g]=p,e[g+1]=y}else{const g=l;for(let u=i,p=c*3,y=c<<1;u<s;u+=r){let S=0,x=0,k=a[o++];for(k+=o;o<k;o++,p+=3,y+=2){const w=m[a[o]].matrix,M=n[p]+g[y],B=n[p+1]+g[y+1],A=n[p+2];S+=(M*w.a+B*w.c+w.tx)*A,x+=(M*w.b+B*w.d+w.ty)*A}e[u]=S,e[u+1]=x}}}copyTo(h){this.bones?(h.bones=new Array(this.bones.length),f.Utils.arrayCopy(this.bones,0,h.bones,0,this.bones.length)):h.bones=null,this.vertices&&(h.vertices=f.Utils.newFloatArray(this.vertices.length),f.Utils.arrayCopy(this.vertices,0,h.vertices,0,this.vertices.length)),h.worldVerticesLength=this.worldVerticesLength,h.timelineAttachment=this.timelineAttachment}};let Z=Ye;Z.nextID=0;class bt extends Z{constructor(t){super(t),this.type=f.AttachmentType.BoundingBox,this.color=new f.Color(1,1,1,1)}copy(){const t=new bt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Tt extends Z{constructor(t){super(t),this.type=f.AttachmentType.Clipping,this.endSlot=null,this.color=new f.Color(.2275,.2275,.8078,1)}copy(){const t=new Tt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class gt extends Z{constructor(t,s){super(t),this.type=f.AttachmentType.Mesh,this.region=null,this.triangles=[],this.color=new f.Color(1,1,1,1),this.width=0,this.height=0,this.hullLength=0,this.edges=[],this.parentMesh=null,this.sequence=null,this.tempColor=new f.Color(0,0,0,0),this.path=s}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new gt(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),f.Utils.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),f.Utils.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),f.Utils.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,s,e,i,r,d){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,s,e,i,r,d)}newLinkedMesh(){const t=new gt(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class pt extends Z{constructor(t){super(t),this.type=f.AttachmentType.Path,this.lengths=[],this.closed=!1,this.constantSpeed=!1,this.color=new f.Color(1,1,1,1)}copy(){const t=new pt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),f.Utils.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class vt extends Z{constructor(t){super(t),this.type=f.AttachmentType.Point,this.x=0,this.y=0,this.rotation=0,this.color=new f.Color(.38,.94,0,1)}computeWorldPosition(t,s){const e=t.matrix;return s.x=this.x*e.a+this.y*e.c+t.worldX,s.y=this.x*e.b+this.y*e.d+t.worldY,s}computeWorldRotation(t){const s=t.matrix,e=f.MathUtils.cosDeg(this.rotation),i=f.MathUtils.sinDeg(this.rotation),r=e*s.a+i*s.c,d=e*s.b+i*s.d;return Math.atan2(d,r)*f.MathUtils.radDeg}copy(){const t=new vt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}const be=class extends Lt{constructor(h,t){super(h),this.type=f.AttachmentType.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new f.Color(1,1,1,1),this.rendererObject=null,this.region=null,this.sequence=null,this.offset=f.Utils.newFloatArray(8),this.uvs=f.Utils.newFloatArray(8),this.tempColor=new f.Color(1,1,1,1),this.path=t}updateRegion(){if(!this.region)throw new Error("Region not set.");const h=this.region,t=this.width/this.region.originalWidth*this.scaleX,s=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*t,i=-this.height/2*this.scaleY+this.region.offsetY*s,r=e+this.region.width*t,d=i+this.region.height*s,l=this.rotation*Math.PI/180,n=Math.cos(l),a=Math.sin(l),o=this.x,c=this.y,m=e*n+o,g=e*a,u=i*n+c,p=i*a,y=r*n+o,S=r*a,x=d*n+c,k=d*a,w=this.offset;w[0]=m-p,w[1]=u+g,w[2]=m-k,w[3]=x+g,w[4]=y-k,w[5]=x+S,w[6]=y-p,w[7]=u+S;const M=this.uvs;h.degrees==90?(M[2]=h.u,M[3]=h.v2,M[4]=h.u,M[5]=h.v,M[6]=h.u2,M[7]=h.v,M[0]=h.u2,M[1]=h.v2):(M[0]=h.u,M[1]=h.v2,M[2]=h.u,M[3]=h.v,M[4]=h.u2,M[5]=h.v,M[6]=h.u2,M[7]=h.v2)}computeWorldVertices(h,t,s,e){this.sequence!=null&&this.sequence.apply(h,this);const i=h.bone,r=this.offset,d=i.matrix,l=d.tx,n=d.ty,a=d.a,o=d.c,c=d.b,m=d.d;let g=0,u=0;g=r[0],u=r[1],t[s]=g*a+u*o+l,t[s+1]=g*c+u*m+n,s+=e,g=r[2],u=r[3],t[s]=g*a+u*o+l,t[s+1]=g*c+u*m+n,s+=e,g=r[4],u=r[5],t[s]=g*a+u*o+l,t[s+1]=g*c+u*m+n,s+=e,g=r[6],u=r[7],t[s]=g*a+u*o+l,t[s+1]=g*c+u*m+n}copy(){const h=new be(this.name,this.path);return h.region=this.region,h.rendererObject=this.rendererObject,h.x=this.x,h.y=this.y,h.scaleX=this.scaleX,h.scaleY=this.scaleY,h.rotation=this.rotation,h.width=this.width,h.height=this.height,f.Utils.arrayCopy(this.uvs,0,h.uvs,0,8),f.Utils.arrayCopy(this.offset,0,h.offset,0,8),h.color.setFromColor(this.color),h.sequence=this.sequence!=null?this.sequence.copy():null,h}};let q=be;q.X1=0,q.Y1=1,q.C1R=2,q.C1G=3,q.C1B=4,q.C1A=5,q.U1=6,q.V1=7,q.X2=8,q.Y2=9,q.C2R=10,q.C2G=11,q.C2B=12,q.C2A=13,q.U2=14,q.V2=15,q.X3=16,q.Y3=17,q.C3R=18,q.C3G=19,q.C3B=20,q.C3A=21,q.U3=22,q.V3=23,q.X4=24,q.Y4=25,q.C4R=26,q.C4G=27,q.C4B=28,q.C4A=29,q.U4=30,q.V4=31;const Xt=class{constructor(t){this.id=Xt.nextID(),this.start=0,this.digits=0,this.setupIndex=0,this.regions=new Array(t)}copy(){const t=new Xt(this.regions.length);return f.Utils.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,s){let e=t.sequenceIndex;e==-1&&(e=this.setupIndex),e>=this.regions.length&&(e=this.regions.length-1);const i=this.regions[e];s.region!=i&&(s.region=i)}getPath(t,s){let e=t;const i=(this.start+s).toString();for(let r=this.digits-i.length;r>0;r--)e+="0";return e+=i,e}static nextID(){return Xt._nextID++}};let Ft=Xt;Ft._nextID=0;var rt=(h=>(h[h.hold=0]="hold",h[h.once=1]="once",h[h.loop=2]="loop",h[h.pingpong=3]="pingpong",h[h.onceReverse=4]="onceReverse",h[h.loopReverse=5]="loopReverse",h[h.pingpongReverse=6]="pingpongReverse",h))(rt||{});const Nt=[0,1,2,3,4,5,6];class Et{constructor(t,s,e){if(this.timelines=[],this.timelineIds=new f.StringSet,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(s),this.duration=e}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let s=0;s<t.length;s++)this.timelineIds.addAll(t[s].getPropertyIds())}hasTimeline(t){for(let s=0;s<t.length;s++)if(this.timelineIds.contains(t[s]))return!0;return!1}apply(t,s,e,i,r,d,l,n){if(!t)throw new Error("skeleton cannot be null.");i&&this.duration!=0&&(e%=this.duration,s>0&&(s%=this.duration));const a=this.timelines;for(let o=0,c=a.length;o<c;o++)a[o].apply(t,s,e,r,d,l,n)}}const W={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};class j{constructor(t,s){this.propertyIds=s,this.frames=f.Utils.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,s){const e=t.length;for(let i=1;i<e;i++)if(t[i]>s)return i-1;return e-1}static search(t,s,e){const i=t.length;for(let r=e;r<i;r+=e)if(t[r]>s)return r-e;return i-e}}class tt extends j{constructor(t,s,e){super(t,e),this.curves=f.Utils.newFloatArray(t+s*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const s=this.getFrameCount()+t*18;if(this.curves.length>s){const e=f.Utils.newFloatArray(s);f.Utils.arrayCopy(this.curves,0,e,0,s),this.curves=e}}setBezier(t,s,e,i,r,d,l,n,a,o,c){const m=this.curves;let g=this.getFrameCount()+t*18;e==0&&(m[s]=2+g);const u=(i-d*2+n)*.03,p=(r-l*2+a)*.03,y=((d-n)*3-i+o)*.006,S=((l-a)*3-r+c)*.006;let x=u*2+y,k=p*2+S,w=(d-i)*.3+u+y*.16666667,M=(l-r)*.3+p+S*.16666667,B=i+w,A=r+M;for(let Y=g+18;g<Y;g+=2)m[g]=B,m[g+1]=A,w+=x,M+=k,x+=y,k+=S,B+=w,A+=M}getBezierValue(t,s,e,i){const r=this.curves;if(r[i]>t){const a=this.frames[s],o=this.frames[s+e];return o+(t-a)/(r[i]-a)*(r[i+1]-o)}const d=i+18;for(i+=2;i<d;i+=2)if(r[i]>=t){const a=r[i-2],o=r[i-1];return o+(t-a)/(r[i]-a)*(r[i+1]-o)}s+=this.getFrameEntries();const l=r[d-2],n=r[d-1];return n+(t-l)/(this.frames[s]-l)*(this.frames[s+e]-n)}}class et extends tt{constructor(t,s,e){super(t,s,[e])}getFrameEntries(){return 2}setFrame(t,s,e){t<<=1,this.frames[t]=s,this.frames[t+1]=e}getCurveValue(t){const s=this.frames;let e=s.length-2;for(let r=2;r<=e;r+=2)if(s[r]>t){e=r-2;break}const i=this.curves[e>>1];switch(i){case 0:const r=s[e],d=s[e+1];return d+(t-r)/(s[e+2]-r)*(s[e+2+1]-d);case 1:return s[e+1]}return this.getBezierValue(t,e,1,i-2)}}class Ut extends tt{constructor(t,s,e,i){super(t,s,[e,i])}getFrameEntries(){return 3}setFrame(t,s,e,i){t*=3,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i}}class At extends et{constructor(t,s,e){super(t,s,`${W.rotate}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,r,d,l){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.rotation=n.data.rotation;return;case f.MixBlend.first:n.rotation+=(n.data.rotation-n.rotation)*r}return}let o=this.getCurveValue(e);switch(d){case f.MixBlend.setup:n.rotation=n.data.rotation+o*r;break;case f.MixBlend.first:case f.MixBlend.replace:o+=n.data.rotation-n.rotation;case f.MixBlend.add:n.rotation+=o*r}}}class Wt extends Ut{constructor(t,s,e){super(t,s,`${W.x}|${e}`,`${W.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,r,d,l){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.x=n.data.x,n.y=n.data.y;return;case f.MixBlend.first:n.x+=(n.data.x-n.x)*r,n.y+=(n.data.y-n.y)*r}return}let o=0,c=0;const m=j.search(a,e,3),g=this.curves[m/3];switch(g){case 0:const u=a[m];o=a[m+1],c=a[m+2];const p=(e-u)/(a[m+3]-u);o+=(a[m+3+1]-o)*p,c+=(a[m+3+2]-c)*p;break;case 1:o=a[m+1],c=a[m+2];break;default:o=this.getBezierValue(e,m,1,g-2),c=this.getBezierValue(e,m,2,g+18-2)}switch(d){case f.MixBlend.setup:n.x=n.data.x+o*r,n.y=n.data.y+c*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.x+=(n.data.x+o-n.x)*r,n.y+=(n.data.y+c-n.y)*r;break;case f.MixBlend.add:n.x+=o*r,n.y+=c*r}}}class Ot extends et{constructor(t,s,e){super(t,s,`${W.x}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,r,d,l){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.x=n.data.x;return;case f.MixBlend.first:n.x+=(n.data.x-n.x)*r}return}const o=this.getCurveValue(e);switch(d){case f.MixBlend.setup:n.x=n.data.x+o*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.x+=(n.data.x+o-n.x)*r;break;case f.MixBlend.add:n.x+=o*r}}}class zt extends et{constructor(t,s,e){super(t,s,`${W.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,r,d,l){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.y=n.data.y;return;case f.MixBlend.first:n.y+=(n.data.y-n.y)*r}return}const o=this.getCurveValue(e);switch(d){case f.MixBlend.setup:n.y=n.data.y+o*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.y+=(n.data.y+o-n.y)*r;break;case f.MixBlend.add:n.y+=o*r}}}class _t extends Ut{constructor(t,s,e){super(t,s,`${W.scaleX}|${e}`,`${W.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,r,d,l){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.scaleX=n.data.scaleX,n.scaleY=n.data.scaleY;return;case f.MixBlend.first:n.scaleX+=(n.data.scaleX-n.scaleX)*r,n.scaleY+=(n.data.scaleY-n.scaleY)*r}return}let o,c;const m=j.search(a,e,3),g=this.curves[m/3];switch(g){case 0:const u=a[m];o=a[m+1],c=a[m+2];const p=(e-u)/(a[m+3]-u);o+=(a[m+3+1]-o)*p,c+=(a[m+3+2]-c)*p;break;case 1:o=a[m+1],c=a[m+2];break;default:o=this.getBezierValue(e,m,1,g-2),c=this.getBezierValue(e,m,2,g+18-2)}if(o*=n.data.scaleX,c*=n.data.scaleY,r==1)d==f.MixBlend.add?(n.scaleX+=o-n.data.scaleX,n.scaleY+=c-n.data.scaleY):(n.scaleX=o,n.scaleY=c);else{let u=0,p=0;if(l==f.MixDirection.mixOut)switch(d){case f.MixBlend.setup:u=n.data.scaleX,p=n.data.scaleY,n.scaleX=u+(Math.abs(o)*f.MathUtils.signum(u)-u)*r,n.scaleY=p+(Math.abs(c)*f.MathUtils.signum(p)-p)*r;break;case f.MixBlend.first:case f.MixBlend.replace:u=n.scaleX,p=n.scaleY,n.scaleX=u+(Math.abs(o)*f.MathUtils.signum(u)-u)*r,n.scaleY=p+(Math.abs(c)*f.MathUtils.signum(p)-p)*r;break;case f.MixBlend.add:n.scaleX+=(o-n.data.scaleX)*r,n.scaleY+=(c-n.data.scaleY)*r}else switch(d){case f.MixBlend.setup:u=Math.abs(n.data.scaleX)*f.MathUtils.signum(o),p=Math.abs(n.data.scaleY)*f.MathUtils.signum(c),n.scaleX=u+(o-u)*r,n.scaleY=p+(c-p)*r;break;case f.MixBlend.first:case f.MixBlend.replace:u=Math.abs(n.scaleX)*f.MathUtils.signum(o),p=Math.abs(n.scaleY)*f.MathUtils.signum(c),n.scaleX=u+(o-u)*r,n.scaleY=p+(c-p)*r;break;case f.MixBlend.add:n.scaleX+=(o-n.data.scaleX)*r,n.scaleY+=(c-n.data.scaleY)*r}}}}class jt extends et{constructor(t,s,e){super(t,s,`${W.scaleX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,r,d,l){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.scaleX=n.data.scaleX;return;case f.MixBlend.first:n.scaleX+=(n.data.scaleX-n.scaleX)*r}return}const o=this.getCurveValue(e)*n.data.scaleX;if(r==1)d==f.MixBlend.add?n.scaleX+=o-n.data.scaleX:n.scaleX=o;else{let c=0;if(l==f.MixDirection.mixOut)switch(d){case f.MixBlend.setup:c=n.data.scaleX,n.scaleX=c+(Math.abs(o)*f.MathUtils.signum(c)-c)*r;break;case f.MixBlend.first:case f.MixBlend.replace:c=n.scaleX,n.scaleX=c+(Math.abs(o)*f.MathUtils.signum(c)-c)*r;break;case f.MixBlend.add:n.scaleX+=(o-n.data.scaleX)*r}else switch(d){case f.MixBlend.setup:c=Math.abs(n.data.scaleX)*f.MathUtils.signum(o),n.scaleX=c+(o-c)*r;break;case f.MixBlend.first:case f.MixBlend.replace:c=Math.abs(n.scaleX)*f.MathUtils.signum(o),n.scaleX=c+(o-c)*r;break;case f.MixBlend.add:n.scaleX+=(o-n.data.scaleX)*r}}}}class Gt extends et{constructor(t,s,e){super(t,s,`${W.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,r,d,l){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.scaleY=n.data.scaleY;return;case f.MixBlend.first:n.scaleY+=(n.data.scaleY-n.scaleY)*r}return}const o=this.getCurveValue(e)*n.data.scaleY;if(r==1)d==f.MixBlend.add?n.scaleY+=o-n.data.scaleY:n.scaleY=o;else{let c=0;if(l==f.MixDirection.mixOut)switch(d){case f.MixBlend.setup:c=n.data.scaleY,n.scaleY=c+(Math.abs(o)*f.MathUtils.signum(c)-c)*r;break;case f.MixBlend.first:case f.MixBlend.replace:c=n.scaleY,n.scaleY=c+(Math.abs(o)*f.MathUtils.signum(c)-c)*r;break;case f.MixBlend.add:n.scaleY+=(o-n.data.scaleY)*r}else switch(d){case f.MixBlend.setup:c=Math.abs(n.data.scaleY)*f.MathUtils.signum(o),n.scaleY=c+(o-c)*r;break;case f.MixBlend.first:case f.MixBlend.replace:c=Math.abs(n.scaleY)*f.MathUtils.signum(o),n.scaleY=c+(o-c)*r;break;case f.MixBlend.add:n.scaleY+=(o-n.data.scaleY)*r}}}}class Ht extends Ut{constructor(t,s,e){super(t,s,`${W.shearX}|${e}`,`${W.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,r,d,l){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.shearX=n.data.shearX,n.shearY=n.data.shearY;return;case f.MixBlend.first:n.shearX+=(n.data.shearX-n.shearX)*r,n.shearY+=(n.data.shearY-n.shearY)*r}return}let o=0,c=0;const m=j.search(a,e,3),g=this.curves[m/3];switch(g){case 0:const u=a[m];o=a[m+1],c=a[m+2];const p=(e-u)/(a[m+3]-u);o+=(a[m+3+1]-o)*p,c+=(a[m+3+2]-c)*p;break;case 1:o=a[m+1],c=a[m+2];break;default:o=this.getBezierValue(e,m,1,g-2),c=this.getBezierValue(e,m,2,g+18-2)}switch(d){case f.MixBlend.setup:n.shearX=n.data.shearX+o*r,n.shearY=n.data.shearY+c*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.shearX+=(n.data.shearX+o-n.shearX)*r,n.shearY+=(n.data.shearY+c-n.shearY)*r;break;case f.MixBlend.add:n.shearX+=o*r,n.shearY+=c*r}}}class Kt extends et{constructor(t,s,e){super(t,s,`${W.shearX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,r,d,l){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.shearX=n.data.shearX;return;case f.MixBlend.first:n.shearX+=(n.data.shearX-n.shearX)*r}return}const o=this.getCurveValue(e);switch(d){case f.MixBlend.setup:n.shearX=n.data.shearX+o*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.shearX+=(n.data.shearX+o-n.shearX)*r;break;case f.MixBlend.add:n.shearX+=o*r}}}class Jt extends et{constructor(t,s,e){super(t,s,`${W.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,r,d,l){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.shearY=n.data.shearY;return;case f.MixBlend.first:n.shearY+=(n.data.shearY-n.shearY)*r}return}const o=this.getCurveValue(e);switch(d){case f.MixBlend.setup:n.shearY=n.data.shearY+o*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.shearY+=(n.data.shearY+o-n.shearY)*r;break;case f.MixBlend.add:n.shearY+=o*r}}}class Qt extends tt{constructor(t,s,e){super(t,s,[`${W.rgb}|${e}`,`${W.alpha}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 5}setFrame(t,s,e,i,r,d){t*=5,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i,this.frames[t+3]=r,this.frames[t+4]=d}apply(t,s,e,i,r,d,l){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=this.frames,o=n.color;if(e<a[0]){const S=n.data.color;switch(d){case f.MixBlend.setup:o.setFromColor(S);return;case f.MixBlend.first:o.add((S.r-o.r)*r,(S.g-o.g)*r,(S.b-o.b)*r,(S.a-o.a)*r)}return}let c=0,m=0,g=0,u=0;const p=j.search(a,e,5),y=this.curves[p/5];switch(y){case 0:const S=a[p];c=a[p+1],m=a[p+2],g=a[p+3],u=a[p+4];const x=(e-S)/(a[p+5]-S);c+=(a[p+5+1]-c)*x,m+=(a[p+5+2]-m)*x,g+=(a[p+5+3]-g)*x,u+=(a[p+5+4]-u)*x;break;case 1:c=a[p+1],m=a[p+2],g=a[p+3],u=a[p+4];break;default:c=this.getBezierValue(e,p,1,y-2),m=this.getBezierValue(e,p,2,y+18-2),g=this.getBezierValue(e,p,3,y+18*2-2),u=this.getBezierValue(e,p,4,y+18*3-2)}r==1?o.set(c,m,g,u):(d==f.MixBlend.setup&&o.setFromColor(n.data.color),o.add((c-o.r)*r,(m-o.g)*r,(g-o.b)*r,(u-o.a)*r))}}class Zt extends tt{constructor(t,s,e){super(t,s,[`${W.rgb}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 4}setFrame(t,s,e,i,r){t<<=2,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i,this.frames[t+3]=r}apply(t,s,e,i,r,d,l){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=this.frames,o=n.color;if(e<a[0]){const y=n.data.color;switch(d){case f.MixBlend.setup:o.r=y.r,o.g=y.g,o.b=y.b;return;case f.MixBlend.first:o.r+=(y.r-o.r)*r,o.g+=(y.g-o.g)*r,o.b+=(y.b-o.b)*r}return}let c=0,m=0,g=0;const u=j.search(a,e,4),p=this.curves[u>>2];switch(p){case 0:const y=a[u];c=a[u+1],m=a[u+2],g=a[u+3];const S=(e-y)/(a[u+4]-y);c+=(a[u+4+1]-c)*S,m+=(a[u+4+2]-m)*S,g+=(a[u+4+3]-g)*S;break;case 1:c=a[u+1],m=a[u+2],g=a[u+3];break;default:c=this.getBezierValue(e,u,1,p-2),m=this.getBezierValue(e,u,2,p+18-2),g=this.getBezierValue(e,u,3,p+18*2-2)}if(r==1)o.r=c,o.g=m,o.b=g;else{if(d==f.MixBlend.setup){const y=n.data.color;o.r=y.r,o.g=y.g,o.b=y.b}o.r+=(c-o.r)*r,o.g+=(m-o.g)*r,o.b+=(g-o.b)*r}}}class te extends et{constructor(t,s,e){super(t,s,`${W.alpha}|${e}`),this.slotIndex=0,this.slotIndex=e}apply(t,s,e,i,r,d,l){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=n.color;if(e<this.frames[0]){const c=n.data.color;switch(d){case f.MixBlend.setup:a.a=c.a;return;case f.MixBlend.first:a.a+=(c.a-a.a)*r}return}const o=this.getCurveValue(e);r==1?a.a=o:(d==f.MixBlend.setup&&(a.a=n.data.color.a),a.a+=(o-a.a)*r)}}class ee extends tt{constructor(t,s,e){super(t,s,[`${W.rgb}|${e}`,`${W.alpha}|${e}`,`${W.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 8}setFrame(t,s,e,i,r,d,l,n,a){t<<=3,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i,this.frames[t+3]=r,this.frames[t+4]=d,this.frames[t+5]=l,this.frames[t+6]=n,this.frames[t+7]=a}apply(t,s,e,i,r,d,l){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=this.frames,o=n.color,c=n.darkColor;if(e<a[0]){const M=n.data.color,B=n.data.darkColor;switch(d){case f.MixBlend.setup:o.setFromColor(M),c.r=B.r,c.g=B.g,c.b=B.b;return;case f.MixBlend.first:o.add((M.r-o.r)*r,(M.g-o.g)*r,(M.b-o.b)*r,(M.a-o.a)*r),c.r+=(B.r-c.r)*r,c.g+=(B.g-c.g)*r,c.b+=(B.b-c.b)*r}return}let m=0,g=0,u=0,p=0,y=0,S=0,x=0;const k=j.search(a,e,8),w=this.curves[k>>3];switch(w){case 0:const M=a[k];m=a[k+1],g=a[k+2],u=a[k+3],p=a[k+4],y=a[k+5],S=a[k+6],x=a[k+7];const B=(e-M)/(a[k+8]-M);m+=(a[k+8+1]-m)*B,g+=(a[k+8+2]-g)*B,u+=(a[k+8+3]-u)*B,p+=(a[k+8+4]-p)*B,y+=(a[k+8+5]-y)*B,S+=(a[k+8+6]-S)*B,x+=(a[k+8+7]-x)*B;break;case 1:m=a[k+1],g=a[k+2],u=a[k+3],p=a[k+4],y=a[k+5],S=a[k+6],x=a[k+7];break;default:m=this.getBezierValue(e,k,1,w-2),g=this.getBezierValue(e,k,2,w+18-2),u=this.getBezierValue(e,k,3,w+18*2-2),p=this.getBezierValue(e,k,4,w+18*3-2),y=this.getBezierValue(e,k,5,w+18*4-2),S=this.getBezierValue(e,k,6,w+18*5-2),x=this.getBezierValue(e,k,7,w+18*6-2)}if(r==1)o.set(m,g,u,p),c.r=y,c.g=S,c.b=x;else{if(d==f.MixBlend.setup){o.setFromColor(n.data.color);const M=n.data.darkColor;c.r=M.r,c.g=M.g,c.b=M.b}o.add((m-o.r)*r,(g-o.g)*r,(u-o.b)*r,(p-o.a)*r),c.r+=(y-c.r)*r,c.g+=(S-c.g)*r,c.b+=(x-c.b)*r}}}class ne extends tt{constructor(t,s,e){super(t,s,[`${W.rgb}|${e}`,`${W.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 7}setFrame(t,s,e,i,r,d,l,n){t*=7,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i,this.frames[t+3]=r,this.frames[t+4]=d,this.frames[t+5]=l,this.frames[t+6]=n}apply(t,s,e,i,r,d,l){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=this.frames,o=n.color,c=n.darkColor;if(e<a[0]){const w=n.data.color,M=n.data.darkColor;switch(d){case f.MixBlend.setup:o.r=w.r,o.g=w.g,o.b=w.b,c.r=M.r,c.g=M.g,c.b=M.b;return;case f.MixBlend.first:o.r+=(w.r-o.r)*r,o.g+=(w.g-o.g)*r,o.b+=(w.b-o.b)*r,c.r+=(M.r-c.r)*r,c.g+=(M.g-c.g)*r,c.b+=(M.b-c.b)*r}return}let m=0,g=0,u=0,p=0,y=0,S=0;const x=j.search(a,e,7),k=this.curves[x/7];switch(k){case 0:const w=a[x];m=a[x+1],g=a[x+2],u=a[x+3],p=a[x+4],y=a[x+5],S=a[x+6];const M=(e-w)/(a[x+7]-w);m+=(a[x+7+1]-m)*M,g+=(a[x+7+2]-g)*M,u+=(a[x+7+3]-u)*M,p+=(a[x+7+4]-p)*M,y+=(a[x+7+5]-y)*M,S+=(a[x+7+6]-S)*M;break;case 1:m=a[x+1],g=a[x+2],u=a[x+3],p=a[x+4],y=a[x+5],S=a[x+6];break;default:m=this.getBezierValue(e,x,1,k-2),g=this.getBezierValue(e,x,2,k+18-2),u=this.getBezierValue(e,x,3,k+18*2-2),p=this.getBezierValue(e,x,4,k+18*3-2),y=this.getBezierValue(e,x,5,k+18*4-2),S=this.getBezierValue(e,x,6,k+18*5-2)}if(r==1)o.r=m,o.g=g,o.b=u,c.r=p,c.g=y,c.b=S;else{if(d==f.MixBlend.setup){const w=n.data.color,M=n.data.darkColor;o.r=w.r,o.g=w.g,o.b=w.b,c.r=M.r,c.g=M.g,c.b=M.b}o.r+=(m-o.r)*r,o.g+=(g-o.g)*r,o.b+=(u-o.b)*r,c.r+=(p-c.r)*r,c.g+=(y-c.g)*r,c.b+=(S-c.b)*r}}}class xt extends j{constructor(t,s){super(t,[`${W.attachment}|${s}`]),this.slotIndex=0,this.slotIndex=s,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,s,e){this.frames[t]=s,this.attachmentNames[t]=e}apply(t,s,e,i,r,d,l){const n=t.slots[this.slotIndex];if(n.bone.active){if(l==f.MixDirection.mixOut){d==f.MixBlend.setup&&this.setAttachment(t,n,n.data.attachmentName);return}if(e<this.frames[0]){(d==f.MixBlend.setup||d==f.MixBlend.first)&&this.setAttachment(t,n,n.data.attachmentName);return}this.setAttachment(t,n,this.attachmentNames[j.search1(this.frames,e)])}}setAttachment(t,s,e){s.setAttachment(e?t.getAttachment(this.slotIndex,e):null)}}class se extends tt{constructor(t,s,e,i){super(t,s,[`${W.deform}|${e}|${i.id}`]),this.slotIndex=0,this.slotIndex=e,this.attachment=i,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,s,e){this.frames[t]=s,this.vertices[t]=e}setBezier(t,s,e,i,r,d,l,n,a,o,c){const m=this.curves;let g=this.getFrameCount()+t*18;e==0&&(m[s]=2+g);const u=(i-d*2+n)*.03,p=a*.03-l*.06,y=((d-n)*3-i+o)*.006,S=(l-a+.33333333)*.018;let x=u*2+y,k=p*2+S,w=(d-i)*.3+u+y*.16666667,M=l*.3+p+S*.16666667,B=i+w,A=M;for(let Y=g+18;g<Y;g+=2)m[g]=B,m[g+1]=A,w+=x,M+=k,x+=y,k+=S,B+=w,A+=M}getCurvePercent(t,s){const e=this.curves;let i=e[s];switch(i){case 0:const n=this.frames[s];return(t-n)/(this.frames[s+this.getFrameEntries()]-n);case 1:return 0}if(i-=2,e[i]>t){const n=this.frames[s];return e[i+1]*(t-n)/(e[i]-n)}const r=i+18;for(i+=2;i<r;i+=2)if(e[i]>=t){const n=e[i-2],a=e[i-1];return a+(t-n)/(e[i]-n)*(e[i+1]-a)}const d=e[r-2],l=e[r-1];return l+(1-l)*(t-d)/(this.frames[s+this.getFrameEntries()]-d)}apply(t,s,e,i,r,d,l){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=n.getAttachment();if(!a||!(a instanceof Z)||a.timelineAttachment!=this.attachment)return;const o=n.deform;o.length==0&&(d=f.MixBlend.setup);const c=this.vertices,m=c[0].length,g=this.frames;if(e<g[0]){switch(d){case f.MixBlend.setup:o.length=0;return;case f.MixBlend.first:if(r==1){o.length=0;return}o.length=m;const x=a;if(x.bones){r=1-r;for(let k=0;k<m;k++)o[k]*=r}else{const k=x.vertices;for(let w=0;w<m;w++)o[w]+=(k[w]-o[w])*r}}return}if(o.length=m,e>=g[g.length-1]){const x=c[g.length-1];if(r==1)if(d==f.MixBlend.add){const k=a;if(k.bones)for(let w=0;w<m;w++)o[w]+=x[w];else{const w=k.vertices;for(let M=0;M<m;M++)o[M]+=x[M]-w[M]}}else f.Utils.arrayCopy(x,0,o,0,m);else switch(d){case f.MixBlend.setup:{const w=a;if(w.bones)for(let M=0;M<m;M++)o[M]=x[M]*r;else{const M=w.vertices;for(let B=0;B<m;B++){const A=M[B];o[B]=A+(x[B]-A)*r}}break}case f.MixBlend.first:case f.MixBlend.replace:for(let w=0;w<m;w++)o[w]+=(x[w]-o[w])*r;break;case f.MixBlend.add:const k=a;if(k.bones)for(let w=0;w<m;w++)o[w]+=x[w]*r;else{const w=k.vertices;for(let M=0;M<m;M++)o[M]+=(x[M]-w[M])*r}}return}const u=j.search1(g,e),p=this.getCurvePercent(e,u),y=c[u],S=c[u+1];if(r==1)if(d==f.MixBlend.add){const x=a;if(x.bones)for(let k=0;k<m;k++){const w=y[k];o[k]+=w+(S[k]-w)*p}else{const k=x.vertices;for(let w=0;w<m;w++){const M=y[w];o[w]+=M+(S[w]-M)*p-k[w]}}}else for(let x=0;x<m;x++){const k=y[x];o[x]=k+(S[x]-k)*p}else switch(d){case f.MixBlend.setup:{const k=a;if(k.bones)for(let w=0;w<m;w++){const M=y[w];o[w]=(M+(S[w]-M)*p)*r}else{const w=k.vertices;for(let M=0;M<m;M++){const B=y[M],A=w[M];o[M]=A+(B+(S[M]-B)*p-A)*r}}break}case f.MixBlend.first:case f.MixBlend.replace:for(let k=0;k<m;k++){const w=y[k];o[k]+=(w+(S[k]-w)*p-o[k])*r}break;case f.MixBlend.add:const x=a;if(x.bones)for(let k=0;k<m;k++){const w=y[k];o[k]+=(w+(S[k]-w)*p)*r}else{const k=x.vertices;for(let w=0;w<m;w++){const M=y[w];o[w]+=(M+(S[w]-M)*p-k[w])*r}}}}}const Te=class extends j{constructor(h){super(h,Te.propertyIds),this.events=new Array(h)}getFrameCount(){return this.frames.length}setFrame(h,t){this.frames[h]=t.time,this.events[h]=t}apply(h,t,s,e,i,r,d){if(!e)return;const l=this.frames,n=this.frames.length;if(t>s)this.apply(h,t,Number.MAX_VALUE,e,i,r,d),t=-1;else if(t>=l[n-1])return;if(s<l[0])return;let a=0;if(t<l[0])a=0;else{a=j.search1(l,t)+1;const o=l[a];for(;a>0&&l[a-1]==o;)a--}for(;a<n&&s>=l[a];a++)e.push(this.events[a])}};let It=Te;It.propertyIds=[`${W.event}`];const ve=class extends j{constructor(t){super(t,ve.propertyIds),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,s,e){this.frames[t]=s,this.drawOrders[t]=e}apply(t,s,e,i,r,d,l){if(l==f.MixDirection.mixOut){d==f.MixBlend.setup&&f.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(e<this.frames[0]){(d==f.MixBlend.setup||d==f.MixBlend.first)&&f.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const n=j.search1(this.frames,e),a=this.drawOrders[n];if(!a)f.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const o=t.drawOrder,c=t.slots;for(let m=0,g=a.length;m<g;m++)o[m]=c[a[m]]}}};let wt=ve;wt.propertyIds=[`${W.drawOrder}`];class ie extends tt{constructor(t,s,e){super(t,s,[`${W.ikConstraint}|${e}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=e}getFrameEntries(){return 6}setFrame(t,s,e,i,r,d,l){t*=6,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i,this.frames[t+3]=r,this.frames[t+4]=d?1:0,this.frames[t+5]=l?1:0}apply(t,s,e,i,r,d,l){const n=t.ikConstraints[this.ikConstraintIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.mix=n.data.mix,n.softness=n.data.softness,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch;return;case f.MixBlend.first:n.mix+=(n.data.mix-n.mix)*r,n.softness+=(n.data.softness-n.softness)*r,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch}return}let o=0,c=0;const m=j.search(a,e,6),g=this.curves[m/6];switch(g){case 0:const u=a[m];o=a[m+1],c=a[m+2];const p=(e-u)/(a[m+6]-u);o+=(a[m+6+1]-o)*p,c+=(a[m+6+2]-c)*p;break;case 1:o=a[m+1],c=a[m+2];break;default:o=this.getBezierValue(e,m,1,g-2),c=this.getBezierValue(e,m,2,g+18-2)}d==f.MixBlend.setup?(n.mix=n.data.mix+(o-n.data.mix)*r,n.softness=n.data.softness+(c-n.data.softness)*r,l==f.MixDirection.mixOut?(n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch):(n.bendDirection=a[m+3],n.compress=a[m+4]!=0,n.stretch=a[m+5]!=0)):(n.mix+=(o-n.mix)*r,n.softness+=(c-n.softness)*r,l==f.MixDirection.mixIn&&(n.bendDirection=a[m+3],n.compress=a[m+4]!=0,n.stretch=a[m+5]!=0))}}class ae extends tt{constructor(t,s,e){super(t,s,[`${W.transformConstraint}|${e}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=e}getFrameEntries(){return 7}setFrame(t,s,e,i,r,d,l,n){const a=this.frames;t*=7,a[t]=s,a[t+1]=e,a[t+2]=i,a[t+3]=r,a[t+4]=d,a[t+5]=l,a[t+6]=n}apply(t,s,e,i,r,d,l){const n=t.transformConstraints[this.transformConstraintIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){const x=n.data;switch(d){case f.MixBlend.setup:n.mixRotate=x.mixRotate,n.mixX=x.mixX,n.mixY=x.mixY,n.mixScaleX=x.mixScaleX,n.mixScaleY=x.mixScaleY,n.mixShearY=x.mixShearY;return;case f.MixBlend.first:n.mixRotate+=(x.mixRotate-n.mixRotate)*r,n.mixX+=(x.mixX-n.mixX)*r,n.mixY+=(x.mixY-n.mixY)*r,n.mixScaleX+=(x.mixScaleX-n.mixScaleX)*r,n.mixScaleY+=(x.mixScaleY-n.mixScaleY)*r,n.mixShearY+=(x.mixShearY-n.mixShearY)*r}return}let o,c,m,g,u,p;const y=j.search(a,e,7),S=this.curves[y/7];switch(S){case 0:const x=a[y];o=a[y+1],c=a[y+2],m=a[y+3],g=a[y+4],u=a[y+5],p=a[y+6];const k=(e-x)/(a[y+7]-x);o+=(a[y+7+1]-o)*k,c+=(a[y+7+2]-c)*k,m+=(a[y+7+3]-m)*k,g+=(a[y+7+4]-g)*k,u+=(a[y+7+5]-u)*k,p+=(a[y+7+6]-p)*k;break;case 1:o=a[y+1],c=a[y+2],m=a[y+3],g=a[y+4],u=a[y+5],p=a[y+6];break;default:o=this.getBezierValue(e,y,1,S-2),c=this.getBezierValue(e,y,2,S+18-2),m=this.getBezierValue(e,y,3,S+18*2-2),g=this.getBezierValue(e,y,4,S+18*3-2),u=this.getBezierValue(e,y,5,S+18*4-2),p=this.getBezierValue(e,y,6,S+18*5-2)}if(d==f.MixBlend.setup){const x=n.data;n.mixRotate=x.mixRotate+(o-x.mixRotate)*r,n.mixX=x.mixX+(c-x.mixX)*r,n.mixY=x.mixY+(m-x.mixY)*r,n.mixScaleX=x.mixScaleX+(g-x.mixScaleX)*r,n.mixScaleY=x.mixScaleY+(u-x.mixScaleY)*r,n.mixShearY=x.mixShearY+(p-x.mixShearY)*r}else n.mixRotate+=(o-n.mixRotate)*r,n.mixX+=(c-n.mixX)*r,n.mixY+=(m-n.mixY)*r,n.mixScaleX+=(g-n.mixScaleX)*r,n.mixScaleY+=(u-n.mixScaleY)*r,n.mixShearY+=(p-n.mixShearY)*r}}class re extends et{constructor(t,s,e){super(t,s,`${W.pathConstraintPosition}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,s,e,i,r,d,l){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.position=n.data.position;return;case f.MixBlend.first:n.position+=(n.data.position-n.position)*r}return}const o=this.getCurveValue(e);d==f.MixBlend.setup?n.position=n.data.position+(o-n.data.position)*r:n.position+=(o-n.position)*r}}class oe extends et{constructor(t,s,e){super(t,s,`${W.pathConstraintSpacing}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,s,e,i,r,d,l){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.spacing=n.data.spacing;return;case f.MixBlend.first:n.spacing+=(n.data.spacing-n.spacing)*r}return}const o=this.getCurveValue(e);d==f.MixBlend.setup?n.spacing=n.data.spacing+(o-n.data.spacing)*r:n.spacing+=(o-n.spacing)*r}}class le extends tt{constructor(t,s,e){super(t,s,[`${W.pathConstraintMix}|${e}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=e}getFrameEntries(){return 4}setFrame(t,s,e,i,r){const d=this.frames;t<<=2,d[t]=s,d[t+1]=e,d[t+2]=i,d[t+3]=r}apply(t,s,e,i,r,d,l){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case f.MixBlend.setup:n.mixRotate=n.data.mixRotate,n.mixX=n.data.mixX,n.mixY=n.data.mixY;return;case f.MixBlend.first:n.mixRotate+=(n.data.mixRotate-n.mixRotate)*r,n.mixX+=(n.data.mixX-n.mixX)*r,n.mixY+=(n.data.mixY-n.mixY)*r}return}let o,c,m;const g=j.search(a,e,4),u=this.curves[g>>2];switch(u){case 0:const p=a[g];o=a[g+1],c=a[g+2],m=a[g+3];const y=(e-p)/(a[g+4]-p);o+=(a[g+4+1]-o)*y,c+=(a[g+4+2]-c)*y,m+=(a[g+4+3]-m)*y;break;case 1:o=a[g+1],c=a[g+2],m=a[g+3];break;default:o=this.getBezierValue(e,g,1,u-2),c=this.getBezierValue(e,g,2,u+18-2),m=this.getBezierValue(e,g,3,u+18*2-2)}if(d==f.MixBlend.setup){const p=n.data;n.mixRotate=p.mixRotate+(o-p.mixRotate)*r,n.mixX=p.mixX+(c-p.mixX)*r,n.mixY=p.mixY+(m-p.mixY)*r}else n.mixRotate+=(o-n.mixRotate)*r,n.mixX+=(c-n.mixX)*r,n.mixY+=(m-n.mixY)*r}}const ft=class extends j{constructor(h,t,s){super(h,[`${W.sequence}|${t}|${s.sequence.id}`]),this.slotIndex=t,this.attachment=s}getFrameEntries(){return ft.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(h,t,s,e,i){const r=this.frames;h*=ft.ENTRIES,r[h]=t,r[h+ft.MODE]=s|e<<4,r[h+ft.DELAY]=i}apply(h,t,s,e,i,r,d){const l=h.slots[this.slotIndex];if(!l.bone.active)return;const n=l.attachment,a=this.attachment;if(n!=a&&(!(n instanceof Z)||n.timelineAttachment!=a))return;const o=this.frames;if(s<o[0]){(r==f.MixBlend.setup||r==f.MixBlend.first)&&(l.sequenceIndex=-1);return}const c=j.search(o,s,ft.ENTRIES),m=o[c],g=o[c+ft.MODE],u=o[c+ft.DELAY];if(!this.attachment.sequence)return;let p=g>>4;const y=this.attachment.sequence.regions.length,S=Nt[g&15];if(S!=rt.hold)switch(p+=(s-m)/u+1e-5|0,S){case rt.once:p=Math.min(y-1,p);break;case rt.loop:p%=y;break;case rt.pingpong:{const x=(y<<1)-2;p=x==0?0:p%x,p>=y&&(p=x-p);break}case rt.onceReverse:p=Math.max(y-1-p,0);break;case rt.loopReverse:p=y-1-p%y;break;case rt.pingpongReverse:{const x=(y<<1)-2;p=x==0?0:(p+y-1)%x,p>=y&&(p=x-p)}}l.sequenceIndex=p}};let Mt=ft;Mt.ENTRIES=3,Mt.MODE=1,Mt.DELAY=2;const ot=class{constructor(h){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new Xe(this),this.propertyIDs=new f.StringSet,this.animationsChanged=!1,this.trackEntryPool=new f.Pool(()=>new Dt),this.data=h}static emptyAnimation(){return ot._emptyAnimation}update(h){h*=this.timeScale;const t=this.tracks;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(!i)continue;i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;let r=h*i.timeScale;if(i.delay>0){if(i.delay-=r,i.delay>0)continue;r=-i.delay,i.delay=0}let d=i.next;if(d){const l=i.trackLast-d.delay;if(l>=0){for(d.delay=0,d.trackTime+=i.timeScale==0?0:(l/i.timeScale+h)*d.timeScale,i.trackTime+=r,this.setCurrent(s,d,!0);d.mixingFrom;)d.mixTime+=h,d=d.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&!i.mixingFrom){t[s]=null,this.queue.end(i),this.clearNext(i);continue}if(i.mixingFrom&&this.updateMixingFrom(i,h)){let l=i.mixingFrom;for(i.mixingFrom=null,l&&(l.mixingTo=null);l;)this.queue.end(l),l=l.mixingFrom}i.trackTime+=r}this.queue.drain()}updateMixingFrom(h,t){const s=h.mixingFrom;if(!s)return!0;const e=this.updateMixingFrom(s,t);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,h.mixTime>0&&h.mixTime>=h.mixDuration?((s.totalAlpha==0||h.mixDuration==0)&&(h.mixingFrom=s.mixingFrom,s.mixingFrom&&(s.mixingFrom.mixingTo=h),h.interruptAlpha=s.interruptAlpha,this.queue.end(s)),e):(s.trackTime+=t*s.timeScale,h.mixTime+=t,!1)}apply(h){if(!h)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,s=this.tracks;let e=!1;for(let d=0,l=s.length;d<l;d++){const n=s[d];if(!n||n.delay>0)continue;e=!0;const a=d==0?f.MixBlend.first:n.mixBlend;let o=n.alpha;n.mixingFrom?o*=this.applyMixingFrom(n,h,a):n.trackTime>=n.trackEnd&&!n.next&&(o=0);const c=n.animationLast,m=n.getAnimationTime();let g=m,u=t;n.reverse&&(g=n.animation.duration-g,u=null);const p=n.animation.timelines,y=p.length;if(d==0&&o==1||a==f.MixBlend.add)for(let S=0;S<y;S++){f.Utils.webkit602BugfixHelper(o,a);const x=p[S];x instanceof xt?this.applyAttachmentTimeline(x,h,g,a,!0):x.apply(h,c,g,u,o,a,f.MixDirection.mixIn)}else{const S=n.timelineMode,x=n.shortestRotation,k=!x&&n.timelinesRotation.length!=y<<1;k&&(n.timelinesRotation.length=y<<1);for(let w=0;w<y;w++){const M=p[w],B=S[w]==he?a:f.MixBlend.setup;!x&&M instanceof At?this.applyRotateTimeline(M,h,g,o,B,n.timelinesRotation,w<<1,k):M instanceof xt?this.applyAttachmentTimeline(M,h,g,a,!0):(f.Utils.webkit602BugfixHelper(o,a),M.apply(h,c,g,u,o,B,f.MixDirection.mixIn))}}this.queueEvents(n,m),t.length=0,n.nextAnimationLast=m,n.nextTrackLast=n.trackTime}const i=this.unkeyedState+Ue,r=h.slots;for(let d=0,l=h.slots.length;d<l;d++){const n=r[d];if(n.attachmentState==i){const a=n.data.attachmentName;n.setAttachment(a?h.getAttachment(n.data.index,a):null)}}return this.unkeyedState+=2,this.queue.drain(),e}applyMixingFrom(h,t,s){const e=h.mixingFrom;e.mixingFrom&&this.applyMixingFrom(e,t,s);let i=0;h.mixDuration==0?(i=1,s==f.MixBlend.first&&(s=f.MixBlend.setup)):(i=h.mixTime/h.mixDuration,i>1&&(i=1),s!=f.MixBlend.first&&(s=e.mixBlend));const r=i<e.attachmentThreshold,d=i<e.drawOrderThreshold,l=e.animation.timelines,n=l.length,a=e.alpha*h.interruptAlpha,o=a*(1-i),c=e.animationLast,m=e.getAnimationTime();let g=m,u=null;if(e.reverse?g=e.animation.duration-g:i<e.eventThreshold&&(u=this.events),s==f.MixBlend.add)for(let p=0;p<n;p++)l[p].apply(t,c,g,u,o,s,f.MixDirection.mixOut);else{const p=e.timelineMode,y=e.timelineHoldMix,S=e.shortestRotation,x=!S&&e.timelinesRotation.length!=n<<1;x&&(e.timelinesRotation.length=n<<1),e.totalAlpha=0;for(let k=0;k<n;k++){const w=l[k];let M=f.MixDirection.mixOut,B,A=0;switch(p[k]){case he:if(!d&&w instanceof wt)continue;B=s,A=o;break;case Fe:B=f.MixBlend.setup,A=o;break;case Ee:B=s,A=a;break;case ce:B=f.MixBlend.setup,A=a;break;default:B=f.MixBlend.setup;const Y=y[k];A=a*Math.max(0,1-Y.mixTime/Y.mixDuration);break}e.totalAlpha+=A,!S&&w instanceof At?this.applyRotateTimeline(w,t,g,A,B,e.timelinesRotation,k<<1,x):w instanceof xt?this.applyAttachmentTimeline(w,t,g,B,r):(f.Utils.webkit602BugfixHelper(A,s),d&&w instanceof wt&&B==f.MixBlend.setup&&(M=f.MixDirection.mixIn),w.apply(t,c,g,u,A,B,M))}}return h.mixDuration>0&&this.queueEvents(e,m),this.events.length=0,e.nextAnimationLast=m,e.nextTrackLast=e.trackTime,i}applyAttachmentTimeline(h,t,s,e,i){const r=t.slots[h.slotIndex];r.bone.active&&(s<h.frames[0]?(e==f.MixBlend.setup||e==f.MixBlend.first)&&this.setAttachment(t,r,r.data.attachmentName,i):this.setAttachment(t,r,h.attachmentNames[j.search1(h.frames,s)],i),r.attachmentState<=this.unkeyedState&&(r.attachmentState=this.unkeyedState+Ue))}setAttachment(h,t,s,e){t.setAttachment(s?h.getAttachment(t.data.index,s):null),e&&(t.attachmentState=this.unkeyedState+Je)}applyRotateTimeline(h,t,s,e,i,r,d,l){if(l&&(r[d]=0),e==1){h.apply(t,0,s,null,1,i,f.MixDirection.mixIn);return}const n=t.bones[h.boneIndex];if(!n.active)return;const a=h.frames;let o=0,c=0;if(s<a[0])switch(i){case f.MixBlend.setup:n.rotation=n.data.rotation;default:return;case f.MixBlend.first:o=n.rotation,c=n.data.rotation}else o=i==f.MixBlend.setup?n.data.rotation:n.rotation,c=n.data.rotation+h.getCurveValue(s);let m=0,g=c-o;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)m=r[d];else{let u=0,p=0;l?(u=0,p=g):(u=r[d],p=r[d+1]);const y=g>0;let S=u>=0;f.MathUtils.signum(p)!=f.MathUtils.signum(g)&&Math.abs(p)<=90&&(Math.abs(u)>180&&(u+=360*f.MathUtils.signum(u)),S=y),m=g+u-u%360,S!=y&&(m+=360*f.MathUtils.signum(u)),r[d]=m}r[d+1]=g,n.rotation=o+m*e}queueEvents(h,t){const s=h.animationStart,e=h.animationEnd,i=e-s,r=h.trackLast%i,d=this.events;let l=0;const n=d.length;for(;l<n;l++){const o=d[l];if(o.time<r)break;o.time>e||this.queue.event(h,o)}let a=!1;for(h.loop?a=i==0||r>h.trackTime%i:a=t>=e&&h.animationLast<e,a&&this.queue.complete(h);l<n;l++){const o=d[l];o.time<s||this.queue.event(h,o)}}clearTracks(){const h=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,s=this.tracks.length;t<s;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=h,this.queue.drain()}clearTrack(h){if(h>=this.tracks.length)return;const t=this.tracks[h];if(!t)return;this.queue.end(t),this.clearNext(t);let s=t;for(;;){const e=s.mixingFrom;if(!e)break;this.queue.end(e),s.mixingFrom=null,s.mixingTo=null,s=e}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(h,t,s){const e=this.expandToIndex(h);this.tracks[h]=t,t.previous=null,e&&(s&&this.queue.interrupt(e),t.mixingFrom=e,e.mixingTo=t,t.mixTime=0,e.mixingFrom&&e.mixDuration>0&&(t.interruptAlpha*=Math.min(1,e.mixTime/e.mixDuration)),e.timelinesRotation.length=0),this.queue.start(t)}setAnimation(h,t,s=!1){const e=this.data.skeletonData.findAnimation(t);if(!e)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(h,e,s)}setAnimationWith(h,t,s=!1){if(!t)throw new Error("animation cannot be null.");let e=!0,i=this.expandToIndex(h);i&&(i.nextTrackLast==-1?(this.tracks[h]=i.mixingFrom,this.queue.interrupt(i),this.queue.end(i),this.clearNext(i),i=i.mixingFrom,e=!1):this.clearNext(i));const r=this.trackEntry(h,t,s,i);return this.setCurrent(h,r,e),this.queue.drain(),r}addAnimation(h,t,s=!1,e=0){const i=this.data.skeletonData.findAnimation(t);if(!i)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(h,i,s,e)}addAnimationWith(h,t,s=!1,e=0){if(!t)throw new Error("animation cannot be null.");let i=this.expandToIndex(h);if(i)for(;i.next;)i=i.next;const r=this.trackEntry(h,t,s,i);return i?(i.next=r,r.previous=i,e<=0&&(e+=i.getTrackComplete()-r.mixDuration)):(this.setCurrent(h,r,!0),this.queue.drain()),r.delay=e,r}setEmptyAnimation(h,t=0){const s=this.setAnimationWith(h,ot.emptyAnimation(),!1);return s.mixDuration=t,s.trackEnd=t,s}addEmptyAnimation(h,t=0,s=0){const e=this.addAnimationWith(h,ot.emptyAnimation(),!1,s);return s<=0&&(e.delay+=e.mixDuration-t),e.mixDuration=t,e.trackEnd=t,e}setEmptyAnimations(h=0){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,e=this.tracks.length;s<e;s++){const i=this.tracks[s];i&&this.setEmptyAnimation(i.trackIndex,h)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(h){return h<this.tracks.length?this.tracks[h]:(f.Utils.ensureArrayCapacity(this.tracks,h+1,null),this.tracks.length=h+1,null)}trackEntry(h,t,s,e){const i=this.trackEntryPool.obtain();return i.reset(),i.trackIndex=h,i.animation=t,i.loop=s,i.holdPrevious=!1,i.reverse=!1,i.shortestRotation=!1,i.eventThreshold=0,i.attachmentThreshold=0,i.drawOrderThreshold=0,i.animationStart=0,i.animationEnd=t.duration,i.animationLast=-1,i.nextAnimationLast=-1,i.delay=0,i.trackTime=0,i.trackLast=-1,i.nextTrackLast=-1,i.trackEnd=Number.MAX_VALUE,i.timeScale=1,i.alpha=1,i.mixTime=0,i.mixDuration=e?this.data.getMix(e.animation,t):0,i.interruptAlpha=1,i.totalAlpha=0,i.mixBlend=f.MixBlend.replace,i}clearNext(h){let t=h.next;for(;t;)this.queue.dispose(t),t=t.next;h.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const h=this.tracks;for(let t=0,s=h.length;t<s;t++){let e=h[t];if(e){for(;e.mixingFrom;)e=e.mixingFrom;do(!e.mixingTo||e.mixBlend!=f.MixBlend.add)&&this.computeHold(e),e=e.mixingTo;while(e)}}}computeHold(h){const t=h.mixingTo,s=h.animation.timelines,e=h.animation.timelines.length,i=h.timelineMode;i.length=e;const r=h.timelineHoldMix;r.length=0;const d=this.propertyIDs;if(t&&t.holdPrevious){for(let l=0;l<e;l++)i[l]=d.addAll(s[l].getPropertyIds())?ce:Ee;return}t:for(let l=0;l<e;l++){const n=s[l],a=n.getPropertyIds();if(!d.addAll(a))i[l]=he;else if(!t||n instanceof xt||n instanceof wt||n instanceof It||!t.animation.hasTimeline(a))i[l]=Fe;else{for(let o=t.mixingTo;o;o=o.mixingTo)if(!o.animation.hasTimeline(a)){if(h.mixDuration>0){i[l]=Ke,r[l]=o;continue t}break}i[l]=ce}}}getCurrent(h){return h>=this.tracks.length?null:this.tracks[h]}addListener(h){if(!h)throw new Error("listener cannot be null.");this.listeners.push(h)}removeListener(h){const t=this.listeners.indexOf(h);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(h,t,s){ot.deprecatedWarning1||(ot.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(h,t,s)}addAnimationByName(h,t,s,e){ot.deprecatedWarning2||(ot.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(h,t,s,e)}hasAnimation(h){return this.data.skeletonData.findAnimation(h)!==null}hasAnimationByName(h){return ot.deprecatedWarning3||(ot.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(h)}};let yt=ot;yt._emptyAnimation=new Et("<empty>",[],0),yt.deprecatedWarning1=!1,yt.deprecatedWarning2=!1,yt.deprecatedWarning3=!1;const ht=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.shortestRotation=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=f.MixBlend.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return ht.deprecatedWarning1||(ht.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){ht.deprecatedWarning1||(ht.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return ht.deprecatedWarning2||(ht.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){ht.deprecatedWarning2||(ht.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Dt=ht;Dt.deprecatedWarning1=!1,Dt.deprecatedWarning2=!1;class Xe{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(K.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(K.interrupt),this.objects.push(t)}end(t){this.objects.push(K.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(K.dispose),this.objects.push(t)}complete(t){this.objects.push(K.complete),this.objects.push(t)}event(t,s){this.objects.push(K.event),this.objects.push(t),this.objects.push(s)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,s=this.animState.listeners;for(let e=0;e<t.length;e+=2){const i=t[e],r=t[e+1];switch(i){case K.start:r.listener&&r.listener.start&&r.listener.start(r);for(let l=0;l<s.length;l++){const n=s[l];n.start&&n.start(r)}break;case K.interrupt:r.listener&&r.listener.interrupt&&r.listener.interrupt(r);for(let l=0;l<s.length;l++){const n=s[l];n.interrupt&&n.interrupt(r)}break;case K.end:r.listener&&r.listener.end&&r.listener.end(r);for(let l=0;l<s.length;l++){const n=s[l];n.end&&n.end(r)}case K.dispose:r.listener&&r.listener.dispose&&r.listener.dispose(r);for(let l=0;l<s.length;l++){const n=s[l];n.dispose&&n.dispose(r)}this.animState.trackEntryPool.free(r);break;case K.complete:r.listener&&r.listener.complete&&r.listener.complete(r);for(let l=0;l<s.length;l++){const n=s[l];n.complete&&n.complete(r)}break;case K.event:const d=t[e+++2];r.listener&&r.listener.event&&r.listener.event(r,d);for(let l=0;l<s.length;l++){const n=s[l];n.event&&n.event(r,d)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var K=(h=>(h[h.start=0]="start",h[h.interrupt=1]="interrupt",h[h.end=2]="end",h[h.dispose=3]="dispose",h[h.complete=4]="complete",h[h.event=5]="event",h))(K||{});class He{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,s){}}const he=0,Fe=1,Ee=2,ce=3,Ke=4,Ue=1,Je=2;class De{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,s,e){const i=this.skeletonData.findAnimation(t);if(!i)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(s);if(!r)throw new Error(`Animation not found: ${s}`);this.setMixWith(i,r,e)}setMixWith(t,s,e){if(!t)throw new Error("from cannot be null.");if(!s)throw new Error("to cannot be null.");const i=`${t.name}.${s.name}`;this.animationToMixTime[i]=e}getMix(t,s){const e=`${t.name}.${s.name}`,i=this.animationToMixTime[e];return i===void 0?this.defaultMix:i}}class Qe{constructor(t){this.atlas=t}loadSequence(t,s,e){const i=e.regions;for(let r=0,d=i.length;r<d;r++){const l=e.getPath(s,r),n=this.atlas.findRegion(l);if(n==null)throw new Error(`Region not found in atlas: ${l} (sequence: ${t})`);i[r]=n,i[r].renderObject=i[r]}}newRegionAttachment(t,s,e,i){const r=new q(s,e);if(i!=null)this.loadSequence(s,e,i);else{const d=this.atlas.findRegion(e);if(!d)throw new Error(`Region not found in atlas: ${e} (region attachment: ${s})`);d.renderObject=d,r.region=d}return r}newMeshAttachment(t,s,e,i){const r=new gt(s,e);if(i!=null)this.loadSequence(s,e,i);else{const d=this.atlas.findRegion(e);if(!d)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${s})`);d.renderObject=d,r.region=d}return r}newBoundingBoxAttachment(t,s){return new bt(s)}newPathAttachment(t,s){return new pt(s)}newPointAttachment(t,s){return new vt(s)}newClippingAttachment(t,s){return new Tt(s)}}class de{constructor(t,s,e){if(this.matrix=new at.Matrix,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!s)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=s,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,s,e,i,r,d,l){this.ax=t,this.ay=s,this.arotation=e,this.ascaleX=i,this.ascaleY=r,this.ashearX=d,this.ashearY=l;const n=this.parent,a=this.matrix,o=this.skeleton.scaleX,c=f.settings.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(!n){const y=this.skeleton,S=e+90+l;a.a=f.MathUtils.cosDeg(e+d)*i*o,a.c=f.MathUtils.cosDeg(S)*r*o,a.b=f.MathUtils.sinDeg(e+d)*i*c,a.d=f.MathUtils.sinDeg(S)*r*c,a.tx=t*o+y.x,a.ty=s*c+y.y;return}let m=n.matrix.a,g=n.matrix.c,u=n.matrix.b,p=n.matrix.d;switch(a.tx=m*t+g*s+n.matrix.tx,a.ty=u*t+p*s+n.matrix.ty,this.data.transformMode){case f.TransformMode.Normal:{const y=e+90+l,S=f.MathUtils.cosDeg(e+d)*i,x=f.MathUtils.cosDeg(y)*r,k=f.MathUtils.sinDeg(e+d)*i,w=f.MathUtils.sinDeg(y)*r;a.a=m*S+g*k,a.c=m*x+g*w,a.b=u*S+p*k,a.d=u*x+p*w;return}case f.TransformMode.OnlyTranslation:{const y=e+90+l;a.a=f.MathUtils.cosDeg(e+d)*i,a.c=f.MathUtils.cosDeg(y)*r,a.b=f.MathUtils.sinDeg(e+d)*i,a.d=f.MathUtils.sinDeg(y)*r;break}case f.TransformMode.NoRotationOrReflection:{let y=m*m+u*u,S=0;y>1e-4?(y=Math.abs(m*p-g*u)/y,m/=o,u/=c,g=u*y,p=m*y,S=Math.atan2(u,m)*f.MathUtils.radDeg):(m=0,u=0,S=90-Math.atan2(p,g)*f.MathUtils.radDeg);const x=e+d-S,k=e+l-S+90,w=f.MathUtils.cosDeg(x)*i,M=f.MathUtils.cosDeg(k)*r,B=f.MathUtils.sinDeg(x)*i,A=f.MathUtils.sinDeg(k)*r;a.a=m*w-g*B,a.c=m*M-g*A,a.b=u*w+p*B,a.d=u*M+p*A;break}case f.TransformMode.NoScale:case f.TransformMode.NoScaleOrReflection:{const y=f.MathUtils.cosDeg(e),S=f.MathUtils.sinDeg(e);let x=(m*y+g*S)/o,k=(u*y+p*S)/c,w=Math.sqrt(x*x+k*k);w>1e-5&&(w=1/w),x*=w,k*=w,w=Math.sqrt(x*x+k*k),this.data.transformMode==f.TransformMode.NoScale&&m*p-g*u<0!=(o<0!=c<0)&&(w=-w);const M=Math.PI/2+Math.atan2(k,x),B=Math.cos(M)*w,A=Math.sin(M)*w,Y=f.MathUtils.cosDeg(d)*i,C=f.MathUtils.cosDeg(90+l)*r,b=f.MathUtils.sinDeg(d)*i,T=f.MathUtils.sinDeg(90+l)*r;a.a=x*Y+B*b,a.c=x*C+B*T,a.b=k*Y+A*b,a.d=k*C+A*T;break}}a.a*=o,a.c*=o,a.b*=c,a.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*f.MathUtils.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*f.MathUtils.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,s=this.matrix;if(!t){this.ax=s.tx-this.skeleton.x,this.ay=s.ty-this.skeleton.y,this.arotation=Math.atan2(s.b,s.a)*f.MathUtils.radDeg,this.ascaleX=Math.sqrt(s.a*s.a+s.b*s.b),this.ascaleY=Math.sqrt(s.c*s.c+s.d*s.d),this.ashearX=0,this.ashearY=Math.atan2(s.a*s.c+s.b*s.d,s.a*s.d-s.b*s.c)*f.MathUtils.radDeg;return}const e=t.matrix,i=1/(e.a*e.d-e.b*e.c),r=s.tx-e.tx,d=s.ty-e.ty;this.ax=r*e.d*i-d*e.c*i,this.ay=d*e.a*i-r*e.b*i;const l=i*e.d,n=i*e.a,a=i*e.c,o=i*e.b,c=l*s.a-a*s.b,m=l*s.c-a*s.d,g=n*s.b-o*s.a,u=n*s.d-o*s.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+g*g),this.ascaleX>1e-4){const p=c*u-m*g;this.ascaleY=p/this.ascaleX,this.ashearY=Math.atan2(c*m+g*u,p)*f.MathUtils.radDeg,this.arotation=Math.atan2(g,c)*f.MathUtils.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(m*m+u*u),this.ashearY=0,this.arotation=90-Math.atan2(u,m)*f.MathUtils.radDeg}worldToLocal(t){const s=this.matrix,e=s.a,i=s.c,r=s.b,d=s.d,l=1/(e*d-i*r),n=t.x-s.tx,a=t.y-s.ty;return t.x=n*d*l-a*i*l,t.y=a*e*l-n*r*l,t}localToWorld(t){const s=this.matrix,e=t.x,i=t.y;return t.x=e*s.a+i*s.c+s.tx,t.y=e*s.b+i*s.d+s.ty,t}worldToLocalRotation(t){const s=f.MathUtils.sinDeg(t),e=f.MathUtils.cosDeg(t),i=this.matrix;return Math.atan2(i.a*s-i.b*e,i.d*e-i.c*s)*f.MathUtils.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const s=f.MathUtils.sinDeg(t),e=f.MathUtils.cosDeg(t),i=this.matrix;return Math.atan2(e*i.b+s*i.d,e*i.a+s*i.c)*f.MathUtils.radDeg}rotateWorld(t){const s=this.matrix,e=s.a,i=s.c,r=s.b,d=s.d,l=f.MathUtils.cosDeg(t),n=f.MathUtils.sinDeg(t);s.a=l*e-n*r,s.c=l*i-n*d,s.b=n*e+l*r,s.d=n*i+l*d}}class me{constructor(t,s,e){if(this.index=0,this.parent=null,this.length=0,this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=f.TransformMode.Normal,this.skinRequired=!1,this.color=new f.Color,t<0)throw new Error("index must be >= 0.");if(!s)throw new Error("name cannot be null.");this.index=t,this.name=s,this.parent=e}}class Rt{constructor(t,s,e){this.name=t,this.order=s,this.skinRequired=e}}class ue{constructor(t,s){if(this.intValue=0,this.floatValue=0,this.stringValue=null,this.time=0,this.volume=0,this.balance=0,!s)throw new Error("data cannot be null.");this.time=t,this.data=s}}class fe{constructor(t){this.intValue=0,this.floatValue=0,this.stringValue=null,this.audioPath=null,this.volume=0,this.balance=0,this.name=t}}class Re{constructor(t,s){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!s)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let i=0;i<t.bones.length;i++){const r=s.findBone(t.bones[i].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[i].name}`);this.bones.push(r)}const e=s.findBone(t.target.name);if(!e)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=e}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,s=this.bones;switch(s.length){case 1:this.apply1(s[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(s[0],s[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,s,e,i,r,d,l){const n=t.parent.matrix;if(!n)throw new Error("IK bone must have parent.");const a=n.a;let o=n.c;const c=n.b;let m=n.d,g=-t.ashearX-t.arotation,u=0,p=0;const y=t.skeleton.scaleX,S=f.settings.yDown?-t.skeleton.scaleY:t.skeleton.scaleY;switch(t.data.transformMode){case f.TransformMode.OnlyTranslation:u=s-t.worldX,p=e-t.worldY,f.settings.yDown&&(p=-p);break;case f.TransformMode.NoRotationOrReflection:const w=Math.abs(a*m-o*c)/(a*a+c*c),M=a/y,B=c/S;o=-B*w*y,m=M*w*S,g+=Math.atan2(B,M)*f.MathUtils.radDeg;default:const A=s-n.tx,Y=e-n.ty,C=a*m-o*c;u=(A*m-Y*o)/C-t.ax,p=(Y*a-A*c)/C-t.ay}g+=Math.atan2(p,u)*f.MathUtils.radDeg,t.ascaleX<0&&(g+=180),g>180?g-=360:g<-180&&(g+=360);let x=t.ascaleX,k=t.ascaleY;if(i||r){switch(t.data.transformMode){case f.TransformMode.NoScale:case f.TransformMode.NoScaleOrReflection:u=s-t.worldX,p=e-t.worldY}const w=t.data.length*x,M=Math.sqrt(u*u+p*p);if(i&&M<w||r&&M>w&&w>1e-4){const B=(M/w-1)*l+1;x*=B,d&&(k*=B)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+g*l,x,k,t.ashearX,t.ashearY)}apply2(t,s,e,i,r,d,l,n,a){const o=t.ax,c=t.ay;let m=t.ascaleX,g=t.ascaleY,u=m,p=g,y=s.ascaleX;const S=t.matrix;let x=0,k=0,w=0;m<0?(m=-m,x=180,w=-1):(x=0,w=1),g<0&&(g=-g,w=-w),y<0?(y=-y,k=180):k=0;const M=s.ax;let B=0,A=0,Y=0,C=S.a,b=S.c,T=S.b,v=S.d;const F=Math.abs(m-g)<=1e-4;!F||d?(B=0,A=C*M+S.tx,Y=T*M+S.ty):(B=s.ay,A=C*M+b*B+S.tx,Y=T*M+v*B+S.ty);const E=t.parent.matrix;if(!E)throw new Error("IK parent must itself have a parent.");C=E.a,b=E.c,T=E.b,v=E.d;const V=1/(C*v-b*T);let D=A-E.tx,U=Y-E.ty;const N=(D*v-U*b)*V-o,O=(U*C-D*T)*V-c,z=Math.sqrt(N*N+O*O);let H=s.data.length*y,R,P;if(z<1e-4){this.apply1(t,e,i,!1,d,!1,a),s.updateWorldTransformWith(M,B,0,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY);return}D=e-E.tx,U=i-E.ty;let _=(D*v-U*b)*V-o,Q=(U*C-D*T)*V-c,it=_*_+Q*Q;if(n!=0){n*=m*(y+1)*.5;const J=Math.sqrt(it),mt=J-z-H*m+n;if(mt>0){let ut=Math.min(1,mt/(n*2))-1;ut=(mt-n*(1-ut*ut))/J,_-=ut*_,Q-=ut*Q,it=_*_+Q*Q}}t:if(F){H*=m;let J=(it-z*z-H*H)/(2*z*H);J<-1?(J=-1,P=Math.PI*r):J>1?(J=1,P=0,d&&(C=(Math.sqrt(it)/(z+H)-1)*a+1,u*=C,l&&(p*=C))):P=Math.acos(J)*r,C=z+H*J,b=H*Math.sin(P),R=Math.atan2(Q*C-_*b,_*C+Q*b)}else{C=m*H,b=g*H;const J=C*C,mt=b*b,ut=Math.atan2(Q,_);T=mt*z*z+J*it-J*mt;const Vt=-2*mt*z,Ne=mt-J;if(v=Vt*Vt-4*Ne*T,v>=0){let St=Math.sqrt(v);Vt<0&&(St=-St),St=-(Vt+St)*.5;const je=St/Ne,Ge=T/St,Bt=Math.abs(je)<Math.abs(Ge)?je:Ge;if(Bt*Bt<=it){U=Math.sqrt(it-Bt*Bt)*r,R=ut-Math.atan2(U,Bt),P=Math.atan2(U/g,(Bt-z)/m);break t}}let We=f.MathUtils.PI,$t=z-C,Ie=$t*$t,Oe=0,ze=0,qt=z+C,Ce=qt*qt,_e=0;T=-C*z/(J-mt),T>=-1&&T<=1&&(T=Math.acos(T),D=C*Math.cos(T)+z,U=b*Math.sin(T),v=D*D+U*U,v<Ie&&(We=T,Ie=v,$t=D,Oe=U),v>Ce&&(ze=T,Ce=v,qt=D,_e=U)),it<=(Ie+Ce)*.5?(R=ut-Math.atan2(Oe*r,$t),P=We*r):(R=ut-Math.atan2(_e*r,qt),P=ze*r)}const Le=Math.atan2(B,M)*w;let Yt=t.arotation;R=(R-Le)*f.MathUtils.radDeg+x-Yt,R>180?R-=360:R<-180&&(R+=360),t.updateWorldTransformWith(o,c,Yt+R*a,u,p,0,0),Yt=s.arotation,P=((P+Le)*f.MathUtils.radDeg-s.ashearX)*w+k-Yt,P>180?P-=360:P<-180&&(P+=360),s.updateWorldTransformWith(M,B,Yt+P*a,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY)}}class ge extends Rt{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class pe extends Rt{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.positionMode=f.PositionMode.Fixed,this.spacingMode=G.Fixed,this.rotateMode=f.RotateMode.Chain,this.offsetRotation=0,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var G=(h=>(h[h.Length=0]="Length",h[h.Fixed=1]="Fixed",h[h.Percent=2]="Percent",h[h.Proportional=3]="Proportional",h))(G||{});const ct=class{constructor(h,t){if(this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!h)throw new Error("data cannot be null.");if(!t)throw new Error("skeleton cannot be null.");this.data=h,this.bones=new Array;for(let e=0,i=h.bones.length;e<i;e++){const r=t.findBone(h.bones[e].name);if(!r)throw new Error(`Couldn't find bone ${h.bones[e].name}.`);this.bones.push(r)}const s=t.findSlot(h.target.name);if(!s)throw new Error(`Couldn't find target bone ${h.target.name}`);this.target=s,this.position=h.position,this.spacing=h.spacing,this.mixRotate=h.mixRotate,this.mixX=h.mixX,this.mixY=h.mixY}isActive(){return this.active}update(){const h=this.target.getAttachment();if(!(h instanceof pt))return;const t=this.mixRotate,s=this.mixX,e=this.mixY;if(t==0&&s==0&&e==0)return;const i=this.data,r=i.rotateMode==f.RotateMode.Tangent,d=i.rotateMode==f.RotateMode.ChainScale,l=this.bones,n=l.length,a=r?n:n+1,o=f.Utils.setArraySize(this.spaces,a),c=d?this.lengths=f.Utils.setArraySize(this.lengths,n):[],m=this.spacing;switch(i.spacingMode){case G.Percent:if(d)for(let w=0,M=a-1;w<M;w++){const B=l[w],A=B.data.length;if(A<ct.epsilon)c[w]=0;else{const Y=A*B.matrix.a,C=A*B.matrix.b;c[w]=Math.sqrt(Y*Y+C*C)}}f.Utils.arrayFill(o,1,a,m);break;case G.Proportional:let x=0;for(let w=0,M=a-1;w<M;){const B=l[w],A=B.data.length;if(A<ct.epsilon)d&&(c[w]=0),o[++w]=m;else{const Y=A*B.matrix.a,C=A*B.matrix.b,b=Math.sqrt(Y*Y+C*C);d&&(c[w]=b),o[++w]=b,x+=b}}if(x>0){x=a/x*m;for(let w=1;w<a;w++)o[w]*=x}break;default:const k=i.spacingMode==G.Length;for(let w=0,M=a-1;w<M;){const B=l[w],A=B.data.length;if(A<ct.epsilon)d&&(c[w]=0),o[++w]=m;else{const Y=A*B.matrix.a,C=A*B.matrix.b,b=Math.sqrt(Y*Y+C*C);d&&(c[w]=b),o[++w]=(k?A+m:m)*b/A}}}const g=this.computeWorldPositions(h,a,r);let u=g[0],p=g[1],y=i.offsetRotation,S=!1;if(y==0)S=i.rotateMode==f.RotateMode.Chain;else{S=!1;const x=this.target.bone.matrix;y*=x.a*x.d-x.b*x.c>0?f.MathUtils.degRad:-f.MathUtils.degRad}for(let x=0,k=3;x<n;x++,k+=3){const w=l[x],M=w.matrix;M.tx+=(u-M.tx)*s,M.ty+=(p-M.ty)*e;const B=g[k],A=g[k+1],Y=B-u,C=A-p;if(d){const b=c[x];if(b!=0){const T=(Math.sqrt(Y*Y+C*C)/b-1)*t+1;M.a*=T,M.b*=T}}if(u=B,p=A,t>0){const b=M.a,T=M.c,v=M.b,F=M.d;let E=0,V=0,D=0;if(r?E=g[k-1]:o[x+1]==0?E=g[k+2]:E=Math.atan2(C,Y),E-=Math.atan2(v,b),S){V=Math.cos(E),D=Math.sin(E);const U=w.data.length;u+=(U*(V*b-D*v)-Y)*t,p+=(U*(D*b+V*v)-C)*t}else E+=y;E>f.MathUtils.PI?E-=f.MathUtils.PI2:E<-f.MathUtils.PI&&(E+=f.MathUtils.PI2),E*=t,V=Math.cos(E),D=Math.sin(E),M.a=V*b-D*v,M.c=V*T-D*F,M.b=D*b+V*v,M.d=D*T+V*F}w.updateAppliedTransform()}}computeWorldPositions(h,t,s){const e=this.target;let i=this.position;const r=this.spaces,d=f.Utils.setArraySize(this.positions,t*3+2);let l=this.world;const n=h.closed;let a=h.worldVerticesLength,o=a/6,c=ct.NONE;if(!h.constantSpeed){const U=h.lengths;o-=n?1:2;const N=U[o];this.data.positionMode==f.PositionMode.Percent&&(i*=N);let O;switch(this.data.spacingMode){case G.Percent:O=N;break;case G.Proportional:O=N/t;break;default:O=1}l=f.Utils.setArraySize(this.world,8);for(let z=0,H=0,R=0;z<t;z++,H+=3){const P=r[z]*O;i+=P;let _=i;if(n)_%=N,_<0&&(_+=N),R=0;else if(_<0){c!=ct.BEFORE&&(c=ct.BEFORE,h.computeWorldVertices(e,2,4,l,0,2)),this.addBeforePosition(_,l,0,d,H);continue}else if(_>N){c!=ct.AFTER&&(c=ct.AFTER,h.computeWorldVertices(e,a-6,4,l,0,2)),this.addAfterPosition(_-N,l,0,d,H);continue}for(;;R++){const Q=U[R];if(!(_>Q)){if(R==0)_/=Q;else{const it=U[R-1];_=(_-it)/(Q-it)}break}}R!=c&&(c=R,n&&R==o?(h.computeWorldVertices(e,a-4,4,l,0,2),h.computeWorldVertices(e,0,4,l,4,2)):h.computeWorldVertices(e,R*6+2,8,l,0,2)),this.addCurvePosition(_,l[0],l[1],l[2],l[3],l[4],l[5],l[6],l[7],d,H,s||z>0&&P==0)}return d}n?(a+=2,l=f.Utils.setArraySize(this.world,a),h.computeWorldVertices(e,2,a-4,l,0,2),h.computeWorldVertices(e,0,2,l,a-4,2),l[a-2]=l[0],l[a-1]=l[1]):(o--,a-=4,l=f.Utils.setArraySize(this.world,a),h.computeWorldVertices(e,2,a,l,0,2));const m=f.Utils.setArraySize(this.curves,o);let g=0,u=l[0],p=l[1],y=0,S=0,x=0,k=0,w=0,M=0,B=0,A=0,Y=0,C=0,b=0,T=0,v=0,F=0;for(let U=0,N=2;U<o;U++,N+=6)y=l[N],S=l[N+1],x=l[N+2],k=l[N+3],w=l[N+4],M=l[N+5],B=(u-y*2+x)*.1875,A=(p-S*2+k)*.1875,Y=((y-x)*3-u+w)*.09375,C=((S-k)*3-p+M)*.09375,b=B*2+Y,T=A*2+C,v=(y-u)*.75+B+Y*.16666667,F=(S-p)*.75+A+C*.16666667,g+=Math.sqrt(v*v+F*F),v+=b,F+=T,b+=Y,T+=C,g+=Math.sqrt(v*v+F*F),v+=b,F+=T,g+=Math.sqrt(v*v+F*F),v+=b+Y,F+=T+C,g+=Math.sqrt(v*v+F*F),m[U]=g,u=w,p=M;this.data.positionMode==f.PositionMode.Percent&&(i*=g);let E;switch(this.data.spacingMode){case G.Percent:E=g;break;case G.Proportional:E=g/t;break;default:E=1}const V=this.segments;let D=0;for(let U=0,N=0,O=0,z=0;U<t;U++,N+=3){const H=r[U]*E;i+=H;let R=i;if(n)R%=g,R<0&&(R+=g),O=0;else if(R<0){this.addBeforePosition(R,l,0,d,N);continue}else if(R>g){this.addAfterPosition(R-g,l,a-4,d,N);continue}for(;;O++){const P=m[O];if(!(R>P)){if(O==0)R/=P;else{const _=m[O-1];R=(R-_)/(P-_)}break}}if(O!=c){c=O;let P=O*6;for(u=l[P],p=l[P+1],y=l[P+2],S=l[P+3],x=l[P+4],k=l[P+5],w=l[P+6],M=l[P+7],B=(u-y*2+x)*.03,A=(p-S*2+k)*.03,Y=((y-x)*3-u+w)*.006,C=((S-k)*3-p+M)*.006,b=B*2+Y,T=A*2+C,v=(y-u)*.3+B+Y*.16666667,F=(S-p)*.3+A+C*.16666667,D=Math.sqrt(v*v+F*F),V[0]=D,P=1;P<8;P++)v+=b,F+=T,b+=Y,T+=C,D+=Math.sqrt(v*v+F*F),V[P]=D;v+=b,F+=T,D+=Math.sqrt(v*v+F*F),V[8]=D,v+=b+Y,F+=T+C,D+=Math.sqrt(v*v+F*F),V[9]=D,z=0}for(R*=D;;z++){const P=V[z];if(!(R>P)){if(z==0)R/=P;else{const _=V[z-1];R=z+(R-_)/(P-_)}break}}this.addCurvePosition(R*.1,u,p,y,S,x,k,w,M,d,N,s||U>0&&H==0)}return d}addBeforePosition(h,t,s,e,i){const r=t[s],d=t[s+1],l=t[s+2]-r,n=t[s+3]-d,a=Math.atan2(n,l);e[i]=r+h*Math.cos(a),e[i+1]=d+h*Math.sin(a),e[i+2]=a}addAfterPosition(h,t,s,e,i){const r=t[s+2],d=t[s+3],l=r-t[s],n=d-t[s+1],a=Math.atan2(n,l);e[i]=r+h*Math.cos(a),e[i+1]=d+h*Math.sin(a),e[i+2]=a}addCurvePosition(h,t,s,e,i,r,d,l,n,a,o,c){if(h==0||isNaN(h)){a[o]=t,a[o+1]=s,a[o+2]=Math.atan2(i-s,e-t);return}const m=h*h,g=m*h,u=1-h,p=u*u,y=p*u,S=u*h,x=S*3,k=u*x,w=x*h,M=t*y+e*k+r*w+l*g,B=s*y+i*k+d*w+n*g;a[o]=M,a[o+1]=B,c&&(h<.001?a[o+2]=Math.atan2(i-s,e-t):a[o+2]=Math.atan2(B-(s*p+i*S*2+d*m),M-(t*p+e*S*2+r*m)))}};let kt=ct;kt.NONE=-1,kt.BEFORE=-2,kt.AFTER=-3,kt.epsilon=1e-5;class Pe{constructor(t,s){if(this.darkColor=null,this.attachment=null,this.attachmentState=0,this.sequenceIndex=-1,this.deform=new Array,!t)throw new Error("data cannot be null.");if(!s)throw new Error("bone cannot be null.");this.data=t,this.bone=s,this.color=new f.Color,this.darkColor=t.darkColor?new f.Color:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof Z)||!(this.attachment instanceof Z)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}class Ve{constructor(t,s){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new f.Vector2,this.active=!1,!t)throw new Error("data cannot be null.");if(!s)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let i=0;i<t.bones.length;i++){const r=s.findBone(t.bones[i].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[i].name}.`);this.bones.push(r)}const e=s.findBone(t.target.name);if(!e)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=e}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleX==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,s=this.mixX,e=this.mixY,i=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,l=s!=0||e!=0,n=this.target,a=n.matrix,o=a.a,c=a.c,m=a.b,g=a.d,u=o*g-c*m>0?f.MathUtils.degRad:-f.MathUtils.degRad,p=this.data.offsetRotation*u,y=this.data.offsetShearY*u,S=this.bones;for(let x=0,k=S.length;x<k;x++){const w=S[x],M=w.matrix;if(t!=0){const B=M.a,A=M.c,Y=M.b,C=M.d;let b=Math.atan2(m,o)-Math.atan2(Y,B)+p;b>f.MathUtils.PI?b-=f.MathUtils.PI2:b<-f.MathUtils.PI&&(b+=f.MathUtils.PI2),b*=t;const T=Math.cos(b),v=Math.sin(b);M.a=T*B-v*Y,M.c=T*A-v*C,M.b=v*B+T*Y,M.d=v*A+T*C}if(l){const B=this.temp;n.localToWorld(B.set(this.data.offsetX,this.data.offsetY)),M.tx+=(B.x-M.tx)*s,M.ty+=(B.y-M.ty)*e}if(i!=0){let B=Math.sqrt(M.a*M.a+M.b*M.b);B!=0&&(B=(B+(Math.sqrt(o*o+m*m)-B+this.data.offsetScaleX)*i)/B),M.a*=B,M.b*=B}if(r!=0){let B=Math.sqrt(M.c*M.c+M.d*M.d);B!=0&&(B=(B+(Math.sqrt(c*c+g*g)-B+this.data.offsetScaleY)*r)/B),M.c*=B,M.d*=B}if(d>0){const B=M.c,A=M.d,Y=Math.atan2(A,B);let C=Math.atan2(g,c)-Math.atan2(m,o)-(Y-Math.atan2(M.b,M.a));C>f.MathUtils.PI?C-=f.MathUtils.PI2:C<-f.MathUtils.PI&&(C+=f.MathUtils.PI2),C=Y+(C+y)*d;const b=Math.sqrt(B*B+A*A);M.c=Math.cos(C)*b,M.d=Math.sin(C)*b}w.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,s=this.mixX,e=this.mixY,i=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,l=s!=0||e!=0,n=this.target,a=n.matrix,o=a.a,c=a.c,m=a.b,g=a.d,u=o*g-c*m>0?f.MathUtils.degRad:-f.MathUtils.degRad,p=this.data.offsetRotation*u,y=this.data.offsetShearY*u,S=this.bones;for(let x=0,k=S.length;x<k;x++){const w=S[x],M=w.matrix;if(t!=0){const B=M.a,A=M.c,Y=M.b,C=M.d;let b=Math.atan2(m,o)+p;b>f.MathUtils.PI?b-=f.MathUtils.PI2:b<-f.MathUtils.PI&&(b+=f.MathUtils.PI2),b*=t;const T=Math.cos(b),v=Math.sin(b);M.a=T*B-v*Y,M.c=T*A-v*C,M.b=v*B+T*Y,M.d=v*A+T*C}if(l){const B=this.temp;n.localToWorld(B.set(this.data.offsetX,this.data.offsetY)),M.tx+=B.x*s,M.ty+=B.y*e}if(i!=0){const B=(Math.sqrt(o*o+m*m)-1+this.data.offsetScaleX)*i+1;M.a*=B,M.b*=B}if(r!=0){const B=(Math.sqrt(c*c+g*g)-1+this.data.offsetScaleY)*r+1;M.c*=B,M.d*=B}if(d>0){let B=Math.atan2(g,c)-Math.atan2(m,o);B>f.MathUtils.PI?B-=f.MathUtils.PI2:B<-f.MathUtils.PI&&(B+=f.MathUtils.PI2);const A=M.c,Y=M.d;B=Math.atan2(Y,A)+(B-f.MathUtils.PI/2+y)*d;const C=Math.sqrt(A*A+Y*Y);M.c=Math.cos(B)*C,M.d=Math.sin(B)*C}w.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,s=this.mixX,e=this.mixY,i=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,l=this.target,n=this.bones;for(let a=0,o=n.length;a<o;a++){const c=n[a];let m=c.arotation;if(t!=0){let x=l.arotation-m+this.data.offsetRotation;x-=(16384-(16384.499999999996-x/360|0))*360,m+=x*t}let g=c.ax,u=c.ay;g+=(l.ax-g+this.data.offsetX)*s,u+=(l.ay-u+this.data.offsetY)*e;let p=c.ascaleX,y=c.ascaleY;i!=0&&p!=0&&(p=(p+(l.ascaleX-p+this.data.offsetScaleX)*i)/p),r!=0&&y!=0&&(y=(y+(l.ascaleY-y+this.data.offsetScaleY)*r)/y);let S=c.ashearY;if(d!=0){let x=l.ashearY-S+this.data.offsetShearY;x-=(16384-(16384.499999999996-x/360|0))*360,S+=x*d}c.updateWorldTransformWith(g,u,m,p,y,c.ashearX,S)}}applyRelativeLocal(){const t=this.mixRotate,s=this.mixX,e=this.mixY,i=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,l=this.target,n=this.bones;for(let a=0,o=n.length;a<o;a++){const c=n[a],m=c.arotation+(l.arotation+this.data.offsetRotation)*t,g=c.ax+(l.ax+this.data.offsetX)*s,u=c.ay+(l.ay+this.data.offsetY)*e,p=c.ascaleX*((l.ascaleX-1+this.data.offsetScaleX)*i+1),y=c.ascaleY*((l.ascaleY-1+this.data.offsetScaleY)*r+1),S=c.ashearY+(l.ashearY+this.data.offsetShearY)*d;c.updateWorldTransformWith(g,u,m,p,y,c.ashearX,S)}}}const Ct=class{constructor(h){if(this._updateCache=new Array,this.skin=null,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!h)throw new Error("data cannot be null.");this.data=h,this.bones=new Array;for(let t=0;t<h.bones.length;t++){const s=h.bones[t];let e;if(!s.parent)e=new de(s,this,null);else{const i=this.bones[s.parent.index];e=new de(s,this,i),i.children.push(e)}this.bones.push(e)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<h.slots.length;t++){const s=h.slots[t],e=this.bones[s.boneData.index],i=new Pe(s,e);this.slots.push(i),this.drawOrder.push(i)}this.ikConstraints=new Array;for(let t=0;t<h.ikConstraints.length;t++){const s=h.ikConstraints[t];this.ikConstraints.push(new Re(s,this))}this.transformConstraints=new Array;for(let t=0;t<h.transformConstraints.length;t++){const s=h.transformConstraints[t];this.transformConstraints.push(new Ve(s,this))}this.pathConstraints=new Array;for(let t=0;t<h.pathConstraints.length;t++){const s=h.pathConstraints[t];this.pathConstraints.push(new kt(s,this))}this.color=new f.Color(1,1,1,1),this.updateCache()}updateCache(){const h=this._updateCache;h.length=0;const t=this.bones;for(let a=0,o=t.length;a<o;a++){const c=t[a];c.sorted=c.data.skinRequired,c.active=!c.sorted}if(this.skin){const a=this.skin.bones;for(let o=0,c=this.skin.bones.length;o<c;o++){let m=this.bones[a[o].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m)}}const s=this.ikConstraints,e=this.transformConstraints,i=this.pathConstraints,r=s.length,d=e.length,l=i.length,n=r+d+l;t:for(let a=0;a<n;a++){for(let o=0;o<r;o++){const c=s[o];if(c.data.order==a){this.sortIkConstraint(c);continue t}}for(let o=0;o<d;o++){const c=e[o];if(c.data.order==a){this.sortTransformConstraint(c);continue t}}for(let o=0;o<l;o++){const c=i[o];if(c.data.order==a){this.sortPathConstraint(c);continue t}}}for(let a=0,o=t.length;a<o;a++)this.sortBone(t[a])}sortIkConstraint(h){if(h.active=h.target.isActive()&&(!h.data.skinRequired||this.skin&&f.Utils.contains(this.skin.constraints,h.data,!0)),!h.active)return;const t=h.target;this.sortBone(t);const s=h.bones,e=s[0];if(this.sortBone(e),s.length==1)this._updateCache.push(h),this.sortReset(e.children);else{const i=s[s.length-1];this.sortBone(i),this._updateCache.push(h),this.sortReset(e.children),i.sorted=!0}}sortPathConstraint(h){if(h.active=h.target.bone.isActive()&&(!h.data.skinRequired||this.skin&&f.Utils.contains(this.skin.constraints,h.data,!0)),!h.active)return;const t=h.target,s=t.data.index,e=t.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,e),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,e);for(let l=0,n=this.data.skins.length;l<n;l++)this.sortPathConstraintAttachment(this.data.skins[l],s,e);const i=t.getAttachment();i instanceof pt&&this.sortPathConstraintAttachmentWith(i,e);const r=h.bones,d=r.length;for(let l=0;l<d;l++)this.sortBone(r[l]);this._updateCache.push(h);for(let l=0;l<d;l++)this.sortReset(r[l].children);for(let l=0;l<d;l++)r[l].sorted=!0}sortTransformConstraint(h){if(h.active=h.target.isActive()&&(!h.data.skinRequired||this.skin&&f.Utils.contains(this.skin.constraints,h.data,!0)),!h.active)return;this.sortBone(h.target);const t=h.bones,s=t.length;if(h.data.local)for(let e=0;e<s;e++){const i=t[e];this.sortBone(i.parent),this.sortBone(i)}else for(let e=0;e<s;e++)this.sortBone(t[e]);this._updateCache.push(h);for(let e=0;e<s;e++)this.sortReset(t[e].children);for(let e=0;e<s;e++)t[e].sorted=!0}sortPathConstraintAttachment(h,t,s){const e=h.attachments[t];if(e)for(const i in e)this.sortPathConstraintAttachmentWith(e[i],s)}sortPathConstraintAttachmentWith(h,t){if(!(h instanceof pt))return;const s=h.bones;if(!s)this.sortBone(t);else{const e=this.bones;for(let i=0,r=s.length;i<r;){let d=s[i++];for(d+=i;i<d;)this.sortBone(e[s[i++]])}}}sortBone(h){if(!h||h.sorted)return;const t=h.parent;t&&this.sortBone(t),h.sorted=!0,this._updateCache.push(h)}sortReset(h){for(let t=0,s=h.length;t<s;t++){const e=h[t];e.active&&(e.sorted&&this.sortReset(e.children),e.sorted=!1)}}updateWorldTransform(){const h=this.bones;for(let s=0,e=h.length;s<e;s++){const i=h[s];i.ax=i.x,i.ay=i.y,i.arotation=i.rotation,i.ascaleX=i.scaleX,i.ascaleY=i.scaleY,i.ashearX=i.shearX,i.ashearY=i.shearY}const t=this._updateCache;for(let s=0,e=t.length;s<e;s++)t[s].update()}updateWorldTransformWith(h){const t=this.getRootBone(),s=h.matrix.a,e=h.matrix.c,i=h.matrix.b,r=h.matrix.d;t.matrix.tx=s*this.x+e*this.y+h.worldX,t.matrix.ty=i*this.x+r*this.y+h.worldY;const d=t.rotation+90+t.shearY,l=f.MathUtils.cosDeg(t.rotation+t.shearX)*t.scaleX,n=f.MathUtils.cosDeg(d)*t.scaleY,a=f.MathUtils.sinDeg(t.rotation+t.shearX)*t.scaleX,o=f.MathUtils.sinDeg(d)*t.scaleY,c=this.scaleX,m=f.settings.yDown?-this.scaleY:this.scaleY;t.matrix.a=(s*l+e*a)*c,t.matrix.c=(s*n+e*o)*c,t.matrix.b=(i*l+r*a)*m,t.matrix.d=(i*n+r*o)*m;const g=this._updateCache;for(let u=0,p=g.length;u<p;u++){const y=g[u];y!=t&&y.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const h=this.bones;for(let i=0,r=h.length;i<r;i++)h[i].setToSetupPose();const t=this.ikConstraints;for(let i=0,r=t.length;i<r;i++){const d=t[i];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const s=this.transformConstraints;for(let i=0,r=s.length;i<r;i++){const d=s[i],l=d.data;d.mixRotate=l.mixRotate,d.mixX=l.mixX,d.mixY=l.mixY,d.mixScaleX=l.mixScaleX,d.mixScaleY=l.mixScaleY,d.mixShearY=l.mixShearY}const e=this.pathConstraints;for(let i=0,r=e.length;i<r;i++){const d=e[i],l=d.data;d.position=l.position,d.spacing=l.spacing,d.mixRotate=l.mixRotate,d.mixX=l.mixX,d.mixY=l.mixY}}setSlotsToSetupPose(){const h=this.slots;f.Utils.arrayCopy(h,0,this.drawOrder,0,h.length);for(let t=0,s=h.length;t<s;t++)h[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(h){if(!h)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(i.data.name==h)return i}return null}findBoneIndex(h){if(!h)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,e=t.length;s<e;s++)if(t[s].data.name==h)return s;return-1}findSlot(h){if(!h)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(i.data.name==h)return i}return null}findSlotIndex(h){if(!h)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,e=t.length;s<e;s++)if(t[s].data.name==h)return s;return-1}setSkinByName(h){const t=this.data.findSkin(h);if(!t)throw new Error(`Skin not found: ${h}`);this.setSkin(t)}setSkin(h){if(h!=this.skin){if(h)if(this.skin)h.attachAll(this,this.skin);else{const t=this.slots;for(let s=0,e=t.length;s<e;s++){const i=t[s],r=i.data.attachmentName;if(r){const d=h.getAttachment(s,r);d&&i.setAttachment(d)}}}this.skin=h,this.updateCache()}}getAttachmentByName(h,t){const s=this.data.findSlot(h);if(!s)throw new Error(`Can't find slot with name ${h}`);return this.getAttachment(s.index,t)}getAttachment(h,t){if(!t)throw new Error("attachmentName cannot be null.");if(this.skin){const s=this.skin.getAttachment(h,t);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(h,t):null}setAttachment(h,t){if(!h)throw new Error("slotName cannot be null.");const s=this.slots;for(let e=0,i=s.length;e<i;e++){const r=s[e];if(r.data.name==h){let d=null;if(t&&(d=this.getAttachment(e,t),!d))throw new Error(`Attachment not found: ${t}, for slot: ${h}`);r.setAttachment(d);return}}throw new Error(`Slot not found: ${h}`)}findIkConstraint(h){if(!h)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(i.data.name==h)return i}return null}findTransformConstraint(h){if(!h)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(i.data.name==h)return i}return null}findPathConstraint(h){if(!h)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(i.data.name==h)return i}return null}getBoundsRect(){const h=new f.Vector2,t=new f.Vector2;return this.getBounds(h,t),{x:h.x,y:h.y,width:t.x,height:t.y}}getBounds(h,t,s=new Array(2)){if(!h)throw new Error("offset cannot be null.");if(!t)throw new Error("size cannot be null.");const e=this.drawOrder;let i=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,l=Number.NEGATIVE_INFINITY;for(let n=0,a=e.length;n<a;n++){const o=e[n];if(!o.bone.active)continue;let c=0,m=null;const g=o.getAttachment();if(g instanceof q)c=8,m=f.Utils.setArraySize(s,c,0),g.computeWorldVertices(o,m,0,2);else if(g instanceof gt){const u=g;c=u.worldVerticesLength,m=f.Utils.setArraySize(s,c,0),u.computeWorldVertices(o,0,c,m,0,2)}if(m)for(let u=0,p=m.length;u<p;u+=2){const y=m[u],S=m[u+1];i=Math.min(i,y),r=Math.min(r,S),d=Math.max(d,y),l=Math.max(l,S)}}h.set(i,r),t.set(d-i,l-r)}get flipX(){return this.scaleX==-1}set flipX(h){Ct.deprecatedWarning1||(Ct.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=h?1:-1}get flipY(){return this.scaleY==-1}set flipY(h){Ct.deprecatedWarning1||(Ct.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=h?1:-1}};let xe=Ct;xe.deprecatedWarning1=!1;class we{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const s=this.bones;for(let e=0,i=s.length;e<i;e++){const r=s[e];if(r.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const s=this.bones;for(let e=0,i=s.length;e<i;e++)if(s[e].name==t)return e;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let e=0,i=s.length;e<i;e++){const r=s[e];if(r.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let e=0,i=s.length;e<i;e++)if(s[e].name==t)return e;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const s=this.skins;for(let e=0,i=s.length;e<i;e++){const r=s[e];if(r.name==t)return r}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const s=this.events;for(let e=0,i=s.length;e<i;e++){const r=s[e];if(r.name==t)return r}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const s=this.animations;for(let e=0,i=s.length;e<i;e++){const r=s[e];if(r.name==t)return r}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const s=this.ikConstraints;for(let e=0,i=s.length;e<i;e++){const r=s[e];if(r.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const s=this.transformConstraints;for(let e=0,i=s.length;e<i;e++){const r=s[e];if(r.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const s=this.pathConstraints;for(let e=0,i=s.length;e<i;e++){const r=s[e];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const s=this.pathConstraints;for(let e=0,i=s.length;e<i;e++)if(s[e].name==t)return e;return-1}}class Me{constructor(t,s,e){if(this.index=0,this.color=new f.Color(1,1,1,1),this.darkColor=null,this.attachmentName=null,this.blendMode=at.BLEND_MODES.NORMAL,t<0)throw new Error("index must be >= 0.");if(!s)throw new Error("name cannot be null.");if(!e)throw new Error("boneData cannot be null.");this.index=t,this.name=s,this.boneData=e}}class ye extends Rt{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class ke{constructor(t,s,e){this.slotIndex=t,this.name=s,this.attachment=e}}class Pt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,s,e){if(!e)throw new Error("attachment cannot be null.");const i=this.attachments;t>=i.length&&(i.length=t+1),i[t]||(i[t]={}),i[t][s]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const i=t.bones[e];let r=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==i){r=!0;break}r||this.bones.push(i)}for(let e=0;e<t.constraints.length;e++){const i=t.constraints[e];let r=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==i){r=!0;break}r||this.constraints.push(i)}const s=t.getAttachments();for(let e=0;e<s.length;e++){const i=s[e];this.setAttachment(i.slotIndex,i.name,i.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const i=t.bones[e];let r=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==i){r=!0;break}r||this.bones.push(i)}for(let e=0;e<t.constraints.length;e++){const i=t.constraints[e];let r=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==i){r=!0;break}r||this.constraints.push(i)}const s=t.getAttachments();for(let e=0;e<s.length;e++){const i=s[e];i.attachment&&(i.attachment instanceof gt?(i.attachment=i.attachment.newLinkedMesh(),this.setAttachment(i.slotIndex,i.name,i.attachment)):(i.attachment=i.attachment.copy(),this.setAttachment(i.slotIndex,i.name,i.attachment)))}}getAttachment(t,s){const e=this.attachments[t];return e?e[s]:null}removeAttachment(t,s){const e=this.attachments[t];e&&delete e[s]}getAttachments(){const t=new Array;for(let s=0;s<this.attachments.length;s++){const e=this.attachments[s];if(e)for(const i in e){const r=e[i];r&&t.push(new ke(s,i,r))}}return t}getAttachmentsForSlot(t,s){const e=this.attachments[t];if(e)for(const i in e){const r=e[i];r&&s.push(new ke(t,i,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,s){let e=0;for(let i=0;i<t.slots.length;i++){const r=t.slots[i],d=r.getAttachment();if(d&&e<s.attachments.length){const l=s.attachments[e];for(const n in l){const a=l[n];if(d==a){const o=this.getAttachment(e,n);o&&r.setAttachment(o);break}}}e++}}}class $e{constructor(t){this.ver40=!1,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const s=this.scale,e=new we;e.name="";const i=new f.BinaryInput(t),r=i.readInt32(),d=i.readInt32();e.hash=d==0&&r==0?null:d.toString(16)+r.toString(16),e.version=i.readString();const l=e.version.substr(0,3);if(l!=="4.0"&&l!=="4.1"){const c=`Spine 4.1 loader cant load version ${e.version}. Please configure your pixi-spine bundle`;console.error(c)}this.ver40=l==="4.0",e.x=i.readFloat(),e.y=i.readFloat(),e.width=i.readFloat(),e.height=i.readFloat();const n=i.readBoolean();n&&(e.fps=i.readFloat(),e.imagesPath=i.readString(),e.audioPath=i.readString());let a=0;a=i.readInt(!0);for(let c=0;c<a;c++){const m=i.readString();if(!m)throw new Error("String in string table must not be null.");i.strings.push(m)}a=i.readInt(!0);for(let c=0;c<a;c++){const m=i.readString();if(!m)throw new Error("Bone name must not be null.");const g=c==0?null:e.bones[i.readInt(!0)],u=new me(c,m,g);u.rotation=i.readFloat(),u.x=i.readFloat()*s,u.y=i.readFloat()*s,u.scaleX=i.readFloat(),u.scaleY=i.readFloat(),u.shearX=i.readFloat(),u.shearY=i.readFloat(),u.length=i.readFloat()*s,u.transformMode=i.readInt(!0),u.skinRequired=i.readBoolean(),n&&f.Color.rgba8888ToColor(u.color,i.readInt32()),e.bones.push(u)}a=i.readInt(!0);for(let c=0;c<a;c++){const m=i.readString();if(!m)throw new Error("Slot name must not be null.");const g=e.bones[i.readInt(!0)],u=new Me(c,m,g);f.Color.rgba8888ToColor(u.color,i.readInt32());const p=i.readInt32();p!=-1&&f.Color.rgb888ToColor(u.darkColor=new f.Color,p),u.attachmentName=i.readStringRef(),u.blendMode=i.readInt(!0),e.slots.push(u)}a=i.readInt(!0);for(let c=0,m;c<a;c++){const g=i.readString();if(!g)throw new Error("IK constraint data name must not be null.");const u=new ge(g);u.order=i.readInt(!0),u.skinRequired=i.readBoolean(),m=i.readInt(!0);for(let p=0;p<m;p++)u.bones.push(e.bones[i.readInt(!0)]);u.target=e.bones[i.readInt(!0)],u.mix=i.readFloat(),u.softness=i.readFloat()*s,u.bendDirection=i.readByte(),u.compress=i.readBoolean(),u.stretch=i.readBoolean(),u.uniform=i.readBoolean(),e.ikConstraints.push(u)}a=i.readInt(!0);for(let c=0,m;c<a;c++){const g=i.readString();if(!g)throw new Error("Transform constraint data name must not be null.");const u=new ye(g);u.order=i.readInt(!0),u.skinRequired=i.readBoolean(),m=i.readInt(!0);for(let p=0;p<m;p++)u.bones.push(e.bones[i.readInt(!0)]);u.target=e.bones[i.readInt(!0)],u.local=i.readBoolean(),u.relative=i.readBoolean(),u.offsetRotation=i.readFloat(),u.offsetX=i.readFloat()*s,u.offsetY=i.readFloat()*s,u.offsetScaleX=i.readFloat(),u.offsetScaleY=i.readFloat(),u.offsetShearY=i.readFloat(),u.mixRotate=i.readFloat(),u.mixX=i.readFloat(),u.mixY=i.readFloat(),u.mixScaleX=i.readFloat(),u.mixScaleY=i.readFloat(),u.mixShearY=i.readFloat(),e.transformConstraints.push(u)}a=i.readInt(!0);for(let c=0,m;c<a;c++){const g=i.readString();if(!g)throw new Error("Path constraint data name must not be null.");const u=new pe(g);u.order=i.readInt(!0),u.skinRequired=i.readBoolean(),m=i.readInt(!0);for(let p=0;p<m;p++)u.bones.push(e.bones[i.readInt(!0)]);u.target=e.slots[i.readInt(!0)],u.positionMode=i.readInt(!0),u.spacingMode=i.readInt(!0),u.rotateMode=i.readInt(!0),u.offsetRotation=i.readFloat(),u.position=i.readFloat(),u.positionMode==f.PositionMode.Fixed&&(u.position*=s),u.spacing=i.readFloat(),(u.spacingMode==G.Length||u.spacingMode==G.Fixed)&&(u.spacing*=s),u.mixRotate=i.readFloat(),u.mixX=i.readFloat(),u.mixY=i.readFloat(),e.pathConstraints.push(u)}const o=this.readSkin(i,e,!0,n);o&&(e.defaultSkin=o,e.skins.push(o));{let c=e.skins.length;for(f.Utils.setArraySize(e.skins,a=c+i.readInt(!0));c<a;c++){const m=this.readSkin(i,e,!1,n);if(!m)throw new Error("readSkin() should not have returned null.");e.skins[c]=m}}a=this.linkedMeshes.length;for(let c=0;c<a;c++){const m=this.linkedMeshes[c],g=m.skin?e.findSkin(m.skin):e.defaultSkin;if(!g)throw new Error("Not skin found for linked mesh.");if(!m.parent)throw new Error("Linked mesh parent must not be null");const u=g.getAttachment(m.slotIndex,m.parent);if(!u)throw new Error(`Parent mesh not found: ${m.parent}`);m.mesh.timelineAttachment=m.inheritTimeline?u:m.mesh,m.mesh.setParentMesh(u)}this.linkedMeshes.length=0,a=i.readInt(!0);for(let c=0;c<a;c++){const m=i.readStringRef();if(!m)throw new Error;const g=new fe(m);g.intValue=i.readInt(!1),g.floatValue=i.readFloat(),g.stringValue=i.readString(),g.audioPath=i.readString(),g.audioPath&&(g.volume=i.readFloat(),g.balance=i.readFloat()),e.events.push(g)}a=i.readInt(!0);for(let c=0;c<a;c++){const m=i.readString();if(!m)throw new Error("Animatio name must not be null.");e.animations.push(this.readAnimation(i,m,e))}return e}readSkin(t,s,e,i){let r=null,d=0;if(e){if(d=t.readInt(!0),d==0)return null;r=new Pt("default")}else{const l=t.readStringRef();if(!l)throw new Error("Skin name must not be null.");r=new Pt(l),r.bones.length=t.readInt(!0);for(let n=0,a=r.bones.length;n<a;n++)r.bones[n]=s.bones[t.readInt(!0)];for(let n=0,a=t.readInt(!0);n<a;n++)r.constraints.push(s.ikConstraints[t.readInt(!0)]);for(let n=0,a=t.readInt(!0);n<a;n++)r.constraints.push(s.transformConstraints[t.readInt(!0)]);for(let n=0,a=t.readInt(!0);n<a;n++)r.constraints.push(s.pathConstraints[t.readInt(!0)]);d=t.readInt(!0)}for(let l=0;l<d;l++){const n=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readStringRef();if(!c)throw new Error("Attachment name must not be null");const m=this.readAttachment(t,s,r,n,c,i);m&&r.setAttachment(n,c,m)}}return r}readAttachment(t,s,e,i,r,d){const l=this.scale;let n=t.readStringRef();switch(n||(n=r),t.readByte()){case f.AttachmentType.Region:{let a=t.readStringRef();const o=t.readFloat(),c=t.readFloat(),m=t.readFloat(),g=t.readFloat(),u=t.readFloat(),p=t.readFloat(),y=t.readFloat(),S=t.readInt32(),x=this.readSequence(t);a||(a=n);const k=this.attachmentLoader.newRegionAttachment(e,n,a,x);return k?(k.path=a,k.x=c*l,k.y=m*l,k.scaleX=g,k.scaleY=u,k.rotation=o,k.width=p*l,k.height=y*l,f.Color.rgba8888ToColor(k.color,S),k.sequence=x,x==null&&k.updateRegion(),k):null}case f.AttachmentType.BoundingBox:{const a=t.readInt(!0),o=this.readVertices(t,a),c=d?t.readInt32():0,m=this.attachmentLoader.newBoundingBoxAttachment(e,n);return m?(m.worldVerticesLength=a<<1,m.vertices=o.vertices,m.bones=o.bones,d&&f.Color.rgba8888ToColor(m.color,c),m):null}case f.AttachmentType.Mesh:{let a=t.readStringRef();const o=t.readInt32(),c=t.readInt(!0),m=this.readFloatArray(t,c<<1,1),g=this.readShortArray(t),u=this.readVertices(t,c),p=t.readInt(!0),y=this.readSequence(t);let S=[],x=0,k=0;d&&(S=this.readShortArray(t),x=t.readFloat(),k=t.readFloat()),a||(a=n);const w=this.attachmentLoader.newMeshAttachment(e,n,a,y);return w?(w.path=a,f.Color.rgba8888ToColor(w.color,o),w.bones=u.bones,w.vertices=u.vertices,w.worldVerticesLength=c<<1,w.triangles=g,w.regionUVs=new Float32Array(m),w.hullLength=p<<1,w.sequence=y,d&&(w.edges=S,w.width=x*l,w.height=k*l),w):null}case f.AttachmentType.LinkedMesh:{let a=t.readStringRef();const o=t.readInt32(),c=t.readStringRef(),m=t.readStringRef(),g=t.readBoolean(),u=this.readSequence(t);let p=0,y=0;d&&(p=t.readFloat(),y=t.readFloat()),a||(a=n);const S=this.attachmentLoader.newMeshAttachment(e,n,a,u);return S?(S.path=a,f.Color.rgba8888ToColor(S.color,o),S.sequence=u,d&&(S.width=p*l,S.height=y*l),this.linkedMeshes.push(new Ze(S,c,i,m,g)),S):null}case f.AttachmentType.Path:{const a=t.readBoolean(),o=t.readBoolean(),c=t.readInt(!0),m=this.readVertices(t,c),g=f.Utils.newArray(c/3,0);for(let y=0,S=g.length;y<S;y++)g[y]=t.readFloat()*l;const u=d?t.readInt32():0,p=this.attachmentLoader.newPathAttachment(e,n);return p?(p.closed=a,p.constantSpeed=o,p.worldVerticesLength=c<<1,p.vertices=m.vertices,p.bones=m.bones,p.lengths=g,d&&f.Color.rgba8888ToColor(p.color,u),p):null}case f.AttachmentType.Point:{const a=t.readFloat(),o=t.readFloat(),c=t.readFloat(),m=d?t.readInt32():0,g=this.attachmentLoader.newPointAttachment(e,n);return g?(g.x=o*l,g.y=c*l,g.rotation=a,d&&f.Color.rgba8888ToColor(g.color,m),g):null}case f.AttachmentType.Clipping:{const a=t.readInt(!0),o=t.readInt(!0),c=this.readVertices(t,o),m=d?t.readInt32():0,g=this.attachmentLoader.newClippingAttachment(e,n);return g?(g.endSlot=s.slots[a],g.worldVerticesLength=o<<1,g.vertices=c.vertices,g.bones=c.bones,d&&f.Color.rgba8888ToColor(g.color,m),g):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const s=new Ft(t.readInt(!0));return s.start=t.readInt(!0),s.digits=t.readInt(!0),s.setupIndex=t.readInt(!0),s}readDeformTimelineType(t){return this.ver40?qe:t.readByte()}readVertices(t,s){const e=this.scale,i=s<<1,r=new tn;if(!t.readBoolean())return r.vertices=this.readFloatArray(t,i,e),r;const d=new Array,l=new Array;for(let n=0;n<s;n++){const a=t.readInt(!0);l.push(a);for(let o=0;o<a;o++)l.push(t.readInt(!0)),d.push(t.readFloat()*e),d.push(t.readFloat()*e),d.push(t.readFloat())}return r.vertices=f.Utils.toFloatArray(d),r.bones=l,r}readFloatArray(t,s,e){const i=new Array(s);if(e==1)for(let r=0;r<s;r++)i[r]=t.readFloat();else for(let r=0;r<s;r++)i[r]=t.readFloat()*e;return i}readShortArray(t){const s=t.readInt(!0),e=new Array(s);for(let i=0;i<s;i++)e[i]=t.readShort();return e}readAnimation(t,s,e){t.readInt(!0);const i=new Array,r=this.scale;for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readInt(!0);for(let m=0,g=t.readInt(!0);m<g;m++){const u=t.readByte(),p=t.readInt(!0),y=p-1;switch(u){case mn:{const S=new xt(p,c);for(let x=0;x<p;x++)S.setFrame(x,t.readFloat(),t.readStringRef());i.push(S);break}case un:{const S=t.readInt(!0),x=new Qt(p,S,c);let k=t.readFloat(),w=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255;for(let Y=0,C=0;x.setFrame(Y,k,w,M,B,A),Y!=y;Y++){const b=t.readFloat(),T=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,E=t.readUnsignedByte()/255;switch(t.readByte()){case nt:x.setStepped(Y);break;case st:$(t,x,C++,Y,0,k,b,w,T,1),$(t,x,C++,Y,1,k,b,M,v,1),$(t,x,C++,Y,2,k,b,B,F,1),$(t,x,C++,Y,3,k,b,A,E,1)}k=b,w=T,M=v,B=F,A=E}i.push(x);break}case fn:{const S=t.readInt(!0),x=new Zt(p,S,c);let k=t.readFloat(),w=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255;for(let A=0,Y=0;x.setFrame(A,k,w,M,B),A!=y;A++){const C=t.readFloat(),b=t.readUnsignedByte()/255,T=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255;switch(t.readByte()){case nt:x.setStepped(A);break;case st:$(t,x,Y++,A,0,k,C,w,b,1),$(t,x,Y++,A,1,k,C,M,T,1),$(t,x,Y++,A,2,k,C,B,v,1)}k=C,w=b,M=T,B=v}i.push(x);break}case gn:{const S=t.readInt(!0),x=new ee(p,S,c);let k=t.readFloat(),w=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,b=t.readUnsignedByte()/255;for(let T=0,v=0;x.setFrame(T,k,w,M,B,A,Y,C,b),T!=y;T++){const F=t.readFloat(),E=t.readUnsignedByte()/255,V=t.readUnsignedByte()/255,D=t.readUnsignedByte()/255,U=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255,O=t.readUnsignedByte()/255,z=t.readUnsignedByte()/255;switch(t.readByte()){case nt:x.setStepped(T);break;case st:$(t,x,v++,T,0,k,F,w,E,1),$(t,x,v++,T,1,k,F,M,V,1),$(t,x,v++,T,2,k,F,B,D,1),$(t,x,v++,T,3,k,F,A,U,1),$(t,x,v++,T,4,k,F,Y,N,1),$(t,x,v++,T,5,k,F,C,O,1),$(t,x,v++,T,6,k,F,b,z,1)}k=F,w=E,M=V,B=D,A=U,Y=N,C=O,b=z}i.push(x);break}case pn:{const S=t.readInt(!0),x=new ne(p,S,c);let k=t.readFloat(),w=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255;for(let b=0,T=0;x.setFrame(b,k,w,M,B,A,Y,C),b!=y;b++){const v=t.readFloat(),F=t.readUnsignedByte()/255,E=t.readUnsignedByte()/255,V=t.readUnsignedByte()/255,D=t.readUnsignedByte()/255,U=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255;switch(t.readByte()){case nt:x.setStepped(b);break;case st:$(t,x,T++,b,0,k,v,w,F,1),$(t,x,T++,b,1,k,v,M,E,1),$(t,x,T++,b,2,k,v,B,V,1),$(t,x,T++,b,3,k,v,A,D,1),$(t,x,T++,b,4,k,v,Y,U,1),$(t,x,T++,b,5,k,v,C,N,1)}k=v,w=F,M=E,B=V,A=D,Y=U,C=N}i.push(x);break}case xn:{const S=new te(p,t.readInt(!0),c);let x=t.readFloat(),k=t.readUnsignedByte()/255;for(let w=0,M=0;S.setFrame(w,x,k),w!=y;w++){const B=t.readFloat(),A=t.readUnsignedByte()/255;switch(t.readByte()){case nt:S.setStepped(w);break;case st:$(t,S,M++,w,0,x,B,k,A,1)}x=B,k=A}i.push(S)}}}}for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readInt(!0);for(let m=0,g=t.readInt(!0);m<g;m++){const u=t.readByte(),p=t.readInt(!0),y=t.readInt(!0);switch(u){case en:i.push(dt(t,new At(p,y,c),1));break;case nn:i.push(Se(t,new Wt(p,y,c),r));break;case sn:i.push(dt(t,new Ot(p,y,c),r));break;case an:i.push(dt(t,new zt(p,y,c),r));break;case rn:i.push(Se(t,new _t(p,y,c),1));break;case on:i.push(dt(t,new jt(p,y,c),1));break;case ln:i.push(dt(t,new Gt(p,y,c),1));break;case hn:i.push(Se(t,new Ht(p,y,c),1));break;case cn:i.push(dt(t,new Kt(p,y,c),1));break;case dn:i.push(dt(t,new Jt(p,y,c),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readInt(!0),m=t.readInt(!0),g=m-1,u=new ie(m,t.readInt(!0),c);let p=t.readFloat(),y=t.readFloat(),S=t.readFloat()*r;for(let x=0,k=0;u.setFrame(x,p,y,S,t.readByte(),t.readBoolean(),t.readBoolean()),x!=g;x++){const w=t.readFloat(),M=t.readFloat(),B=t.readFloat()*r;switch(t.readByte()){case nt:u.setStepped(x);break;case st:$(t,u,k++,x,0,p,w,y,M,1),$(t,u,k++,x,1,p,w,S,B,r)}p=w,y=M,S=B}i.push(u)}for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readInt(!0),m=t.readInt(!0),g=m-1,u=new ae(m,t.readInt(!0),c);let p=t.readFloat(),y=t.readFloat(),S=t.readFloat(),x=t.readFloat(),k=t.readFloat(),w=t.readFloat(),M=t.readFloat();for(let B=0,A=0;u.setFrame(B,p,y,S,x,k,w,M),B!=g;B++){const Y=t.readFloat(),C=t.readFloat(),b=t.readFloat(),T=t.readFloat(),v=t.readFloat(),F=t.readFloat(),E=t.readFloat();switch(t.readByte()){case nt:u.setStepped(B);break;case st:$(t,u,A++,B,0,p,Y,y,C,1),$(t,u,A++,B,1,p,Y,S,b,1),$(t,u,A++,B,2,p,Y,x,T,1),$(t,u,A++,B,3,p,Y,k,v,1),$(t,u,A++,B,4,p,Y,w,F,1),$(t,u,A++,B,5,p,Y,M,E,1)}p=Y,y=C,S=b,x=T,k=v,w=F,M=E}i.push(u)}for(let a=0,o=t.readInt(!0);a<o;a++){const c=t.readInt(!0),m=e.pathConstraints[c];for(let g=0,u=t.readInt(!0);g<u;g++)switch(t.readByte()){case Mn:i.push(dt(t,new re(t.readInt(!0),t.readInt(!0),c),m.positionMode==f.PositionMode.Fixed?r:1));break;case yn:i.push(dt(t,new oe(t.readInt(!0),t.readInt(!0),c),m.spacingMode==G.Length||m.spacingMode==G.Fixed?r:1));break;case kn:const p=new le(t.readInt(!0),t.readInt(!0),c);let y=t.readFloat(),S=t.readFloat(),x=t.readFloat(),k=t.readFloat();for(let w=0,M=0,B=p.getFrameCount()-1;p.setFrame(w,y,S,x,k),w!=B;w++){const A=t.readFloat(),Y=t.readFloat(),C=t.readFloat(),b=t.readFloat();switch(t.readByte()){case nt:p.setStepped(w);break;case st:$(t,p,M++,w,0,y,A,S,Y,1),$(t,p,M++,w,1,y,A,x,C,1),$(t,p,M++,w,2,y,A,k,b,1)}y=A,S=Y,x=C,k=b}i.push(p)}}for(let a=0,o=t.readInt(!0);a<o;a++){const c=e.skins[t.readInt(!0)];for(let m=0,g=t.readInt(!0);m<g;m++){const u=t.readInt(!0);for(let p=0,y=t.readInt(!0);p<y;p++){const S=t.readStringRef();if(!S)throw new Error("attachmentName must not be null.");const x=c.getAttachment(u,S),k=this.readDeformTimelineType(t),w=t.readInt(!0),M=w-1;switch(k){case qe:{const B=x,A=B.bones,Y=B.vertices,C=A?Y.length/3*2:Y.length,b=t.readInt(!0),T=new se(w,b,u,B);let v=t.readFloat();for(let F=0,E=0;;F++){let V,D=t.readInt(!0);if(D==0)V=A?f.Utils.newFloatArray(C):Y;else{V=f.Utils.newFloatArray(C);const N=t.readInt(!0);if(D+=N,r==1)for(let O=N;O<D;O++)V[O]=t.readFloat();else for(let O=N;O<D;O++)V[O]=t.readFloat()*r;if(!A)for(let O=0,z=V.length;O<z;O++)V[O]+=Y[O]}if(T.setFrame(F,v,V),F==M)break;const U=t.readFloat();switch(t.readByte()){case nt:T.setStepped(F);break;case st:$(t,T,E++,F,0,v,U,0,1,1)}v=U}i.push(T);break}case wn:{const B=new Mt(w,u,x);for(let A=0;A<w;A++){const Y=t.readFloat(),C=t.readInt32();B.setFrame(A,Y,Nt[C&15],C>>4,t.readFloat())}i.push(B);break}}}}}const d=t.readInt(!0);if(d>0){const a=new wt(d),o=e.slots.length;for(let c=0;c<d;c++){const m=t.readFloat(),g=t.readInt(!0),u=f.Utils.newArray(o,0);for(let x=o-1;x>=0;x--)u[x]=-1;const p=f.Utils.newArray(o-g,0);let y=0,S=0;for(let x=0;x<g;x++){const k=t.readInt(!0);for(;y!=k;)p[S++]=y++;u[y+t.readInt(!0)]=y++}for(;y<o;)p[S++]=y++;for(let x=o-1;x>=0;x--)u[x]==-1&&(u[x]=p[--S]);a.setFrame(c,m,u)}i.push(a)}const l=t.readInt(!0);if(l>0){const a=new It(l);for(let o=0;o<l;o++){const c=t.readFloat(),m=e.events[t.readInt(!0)],g=new ue(c,m);g.intValue=t.readInt(!1),g.floatValue=t.readFloat(),g.stringValue=t.readBoolean()?t.readString():m.stringValue,g.data.audioPath&&(g.volume=t.readFloat(),g.balance=t.readFloat()),a.setFrame(o,g)}i.push(a)}let n=0;for(let a=0,o=i.length;a<o;a++)n=Math.max(n,i[a].getDuration());return new Et(s,i,n)}}$e.BlendModeValues=[at.BLEND_MODES.NORMAL,at.BLEND_MODES.ADD,at.BLEND_MODES.MULTIPLY,at.BLEND_MODES.SCREEN];class Ze{constructor(t,s,e,i,r){this.mesh=t,this.skin=s,this.slotIndex=e,this.parent=i,this.inheritTimeline=r}}class tn{constructor(t=null,s=null){this.bones=t,this.vertices=s}}function dt(h,t,s){let e=h.readFloat(),i=h.readFloat()*s;for(let r=0,d=0,l=t.getFrameCount()-1;t.setFrame(r,e,i),r!=l;r++){const n=h.readFloat(),a=h.readFloat()*s;switch(h.readByte()){case nt:t.setStepped(r);break;case st:$(h,t,d++,r,0,e,n,i,a,s)}e=n,i=a}return t}function Se(h,t,s){let e=h.readFloat(),i=h.readFloat()*s,r=h.readFloat()*s;for(let d=0,l=0,n=t.getFrameCount()-1;t.setFrame(d,e,i,r),d!=n;d++){const a=h.readFloat(),o=h.readFloat()*s,c=h.readFloat()*s;switch(h.readByte()){case nt:t.setStepped(d);break;case st:$(h,t,l++,d,0,e,a,i,o,s),$(h,t,l++,d,1,e,a,r,c,s)}e=a,i=o,r=c}return t}function $(h,t,s,e,i,r,d,l,n,a){t.setBezier(s,e,i,r,l,h.readFloat(),h.readFloat()*a,h.readFloat(),h.readFloat()*a,d,n)}const en=0,nn=1,sn=2,an=3,rn=4,on=5,ln=6,hn=7,cn=8,dn=9,mn=0,un=1,fn=2,gn=3,pn=4,xn=5,qe=0,wn=1,Mn=0,yn=1,kn=2,nt=1,st=2;class Sn extends f.SkeletonBoundsBase{}class Be{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const s=this.scale,e=new we,i=typeof t=="string"?JSON.parse(t):t,r=i.skeleton;if(r){e.hash=r.hash,e.version=r.spine;const d=e.version.substr(0,3);if(d!=="4.0"&&d!=="4.1"){const l=`Spine 4.1 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(l)}e.x=r.x,e.y=r.y,e.width=r.width,e.height=r.height,e.fps=r.fps,e.imagesPath=r.images}if(i.bones)for(let d=0;d<i.bones.length;d++){const l=i.bones[d];let n=null;const a=I(l,"parent",null);if(a!=null&&(n=e.findBone(a),n==null))throw new Error(`Parent bone not found: ${a}`);const o=new me(e.bones.length,l.name,n);o.length=I(l,"length",0)*s,o.x=I(l,"x",0)*s,o.y=I(l,"y",0)*s,o.rotation=I(l,"rotation",0),o.scaleX=I(l,"scaleX",1),o.scaleY=I(l,"scaleY",1),o.shearX=I(l,"shearX",0),o.shearY=I(l,"shearY",0),o.transformMode=f.Utils.enumValue(f.TransformMode,I(l,"transform","Normal")),o.skinRequired=I(l,"skin",!1);const c=I(l,"color",null);c&&o.color.setFromString(c),e.bones.push(o)}if(i.slots)for(let d=0;d<i.slots.length;d++){const l=i.slots[d],n=e.findBone(l.bone);if(!n)throw new Error(`Couldn't find bone ${l.bone} for slot ${l.name}`);const a=new Me(e.slots.length,l.name,n),o=I(l,"color",null);o&&a.color.setFromString(o);const c=I(l,"dark",null);c&&(a.darkColor=f.Color.fromString(c)),a.attachmentName=I(l,"attachment",null),a.blendMode=Be.blendModeFromString(I(l,"blend","normal")),e.slots.push(a)}if(i.ik)for(let d=0;d<i.ik.length;d++){const l=i.ik[d],n=new ge(l.name);n.order=I(l,"order",0),n.skinRequired=I(l,"skin",!1);for(let a=0;a<l.bones.length;a++){const o=l.bones[a],c=e.findBone(o);if(c==null)throw new Error(`IK bone not found: ${o}`);n.bones.push(c)}n.target=e.findBone(l.target),n.mix=I(l,"mix",1),n.softness=I(l,"softness",0)*s,n.bendDirection=I(l,"bendPositive",!0)?1:-1,n.compress=I(l,"compress",!1),n.stretch=I(l,"stretch",!1),n.uniform=I(l,"uniform",!1),e.ikConstraints.push(n)}if(i.transform)for(let d=0;d<i.transform.length;d++){const l=i.transform[d],n=new ye(l.name);n.order=I(l,"order",0),n.skinRequired=I(l,"skin",!1);for(let c=0;c<l.bones.length;c++){const m=l.bones[c],g=e.findBone(m);if(!g)throw new Error(`Couldn't find bone ${m} for transform constraint ${l.name}.`);n.bones.push(g)}const a=l.target,o=e.findBone(a);if(!o)throw new Error(`Couldn't find target bone ${a} for transform constraint ${l.name}.`);n.target=o,n.local=I(l,"local",!1),n.relative=I(l,"relative",!1),n.offsetRotation=I(l,"rotation",0),n.offsetX=I(l,"x",0)*s,n.offsetY=I(l,"y",0)*s,n.offsetScaleX=I(l,"scaleX",0),n.offsetScaleY=I(l,"scaleY",0),n.offsetShearY=I(l,"shearY",0),n.mixRotate=I(l,"mixRotate",1),n.mixX=I(l,"mixX",1),n.mixY=I(l,"mixY",n.mixX),n.mixScaleX=I(l,"mixScaleX",1),n.mixScaleY=I(l,"mixScaleY",n.mixScaleX),n.mixShearY=I(l,"mixShearY",1),e.transformConstraints.push(n)}if(i.path)for(let d=0;d<i.path.length;d++){const l=i.path[d],n=new pe(l.name);n.order=I(l,"order",0),n.skinRequired=I(l,"skin",!1);for(let c=0;c<l.bones.length;c++){const m=l.bones[c],g=e.findBone(m);if(!g)throw new Error(`Couldn't find bone ${m} for path constraint ${l.name}.`);n.bones.push(g)}const a=l.target,o=e.findSlot(a);if(!o)throw new Error(`Couldn't find target slot ${a} for path constraint ${l.name}.`);n.target=o,n.positionMode=f.Utils.enumValue(f.PositionMode,I(l,"positionMode","Percent")),n.spacingMode=f.Utils.enumValue(G,I(l,"spacingMode","Length")),n.rotateMode=f.Utils.enumValue(f.RotateMode,I(l,"rotateMode","Tangent")),n.offsetRotation=I(l,"rotation",0),n.position=I(l,"position",0),n.positionMode==f.PositionMode.Fixed&&(n.position*=s),n.spacing=I(l,"spacing",0),(n.spacingMode==G.Length||n.spacingMode==G.Fixed)&&(n.spacing*=s),n.mixRotate=I(l,"mixRotate",1),n.mixX=I(l,"mixX",1),n.mixY=I(l,"mixY",n.mixX),e.pathConstraints.push(n)}if(i.skins)for(let d=0;d<i.skins.length;d++){const l=i.skins[d],n=new Pt(l.name);if(l.bones)for(let a=0;a<l.bones.length;a++){const o=l.bones[a],c=e.findBone(o);if(!c)throw new Error(`Couldn't find bone ${o} for skin ${l.name}.`);n.bones.push(c)}if(l.ik)for(let a=0;a<l.ik.length;a++){const o=l.ik[a],c=e.findIkConstraint(o);if(!c)throw new Error(`Couldn't find IK constraint ${o} for skin ${l.name}.`);n.constraints.push(c)}if(l.transform)for(let a=0;a<l.transform.length;a++){const o=l.transform[a],c=e.findTransformConstraint(o);if(!c)throw new Error(`Couldn't find transform constraint ${o} for skin ${l.name}.`);n.constraints.push(c)}if(l.path)for(let a=0;a<l.path.length;a++){const o=l.path[a],c=e.findPathConstraint(o);if(!c)throw new Error(`Couldn't find path constraint ${o} for skin ${l.name}.`);n.constraints.push(c)}for(const a in l.attachments){const o=e.findSlot(a);if(!o)throw new Error(`Couldn't find slot ${a} for skin ${l.name}.`);const c=l.attachments[a];for(const m in c){const g=this.readAttachment(c[m],n,o.index,m,e);g&&n.setAttachment(o.index,m,g)}}e.skins.push(n),n.name=="default"&&(e.defaultSkin=n)}for(let d=0,l=this.linkedMeshes.length;d<l;d++){const n=this.linkedMeshes[d],a=n.skin?e.findSkin(n.skin):e.defaultSkin;if(!a)throw new Error(`Skin not found: ${n.skin}`);const o=a.getAttachment(n.slotIndex,n.parent);if(!o)throw new Error(`Parent mesh not found: ${n.parent}`);n.mesh.timelineAttachment=n.inheritTimeline?o:n.mesh,n.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,i.events)for(const d in i.events){const l=i.events[d],n=new fe(d);n.intValue=I(l,"int",0),n.floatValue=I(l,"float",0),n.stringValue=I(l,"string",""),n.audioPath=I(l,"audio",null),n.audioPath&&(n.volume=I(l,"volume",1),n.balance=I(l,"balance",0)),e.events.push(n)}if(i.animations)for(const d in i.animations){const l=i.animations[d];this.readAnimation(l,d,e)}return e}readAttachment(t,s,e,i,r){const d=this.scale;switch(i=I(t,"name",i),I(t,"type","region")){case"region":{const l=I(t,"path",i),n=this.readSequence(I(t,"sequence",null)),a=this.attachmentLoader.newRegionAttachment(s,i,l,n);if(!a)return null;a.path=l,a.x=I(t,"x",0)*d,a.y=I(t,"y",0)*d,a.scaleX=I(t,"scaleX",1),a.scaleY=I(t,"scaleY",1),a.rotation=I(t,"rotation",0),a.width=t.width*d,a.height=t.height*d,a.sequence=n;const o=I(t,"color",null);return o&&a.color.setFromString(o),a}case"boundingbox":{const l=this.attachmentLoader.newBoundingBoxAttachment(s,i);if(!l)return null;this.readVertices(t,l,t.vertexCount<<1);const n=I(t,"color",null);return n&&l.color.setFromString(n),l}case"mesh":case"linkedmesh":{const l=I(t,"path",i),n=this.readSequence(I(t,"sequence",null)),a=this.attachmentLoader.newMeshAttachment(s,i,l,n);if(!a)return null;a.path=l;const o=I(t,"color",null);o&&a.color.setFromString(o),a.width=I(t,"width",0)*d,a.height=I(t,"height",0)*d,a.sequence=n;const c=I(t,"parent",null);if(c)return this.linkedMeshes.push(new Bn(a,I(t,"skin",null),e,c,I(t,"timelines",!0))),a;const m=t.uvs;return this.readVertices(t,a,m.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(m),a.edges=I(t,"edges",null),a.hullLength=I(t,"hull",0)*2,a}case"path":{const l=this.attachmentLoader.newPathAttachment(s,i);if(!l)return null;l.closed=I(t,"closed",!1),l.constantSpeed=I(t,"constantSpeed",!0);const n=t.vertexCount;this.readVertices(t,l,n<<1);const a=f.Utils.newArray(n/3,0);for(let c=0;c<t.lengths.length;c++)a[c]=t.lengths[c]*d;l.lengths=a;const o=I(t,"color",null);return o&&l.color.setFromString(o),l}case"point":{const l=this.attachmentLoader.newPointAttachment(s,i);if(!l)return null;l.x=I(t,"x",0)*d,l.y=I(t,"y",0)*d,l.rotation=I(t,"rotation",0);const n=I(t,"color",null);return n&&l.color.setFromString(n),l}case"clipping":{const l=this.attachmentLoader.newClippingAttachment(s,i);if(!l)return null;const n=I(t,"end",null);if(n!=null){const c=r.findSlot(n);if(c==null)throw new Error(`Clipping end slot not found: ${n}`);l.endSlot=c}const a=t.vertexCount;this.readVertices(t,l,a<<1);const o=I(t,"color",null);return o&&l.color.setFromString(o),l}}return null}readSequence(t){if(t==null)return null;const s=new Ft(I(t,"count",0));return s.start=I(t,"start",1),s.digits=I(t,"digits",0),s.setupIndex=I(t,"setup",0),s}readVertices(t,s,e){const i=this.scale;s.worldVerticesLength=e;const r=t.vertices;if(e==r.length){const n=f.Utils.toFloatArray(r);if(i!=1)for(let a=0,o=r.length;a<o;a++)n[a]*=i;s.vertices=n;return}const d=new Array,l=new Array;for(let n=0,a=r.length;n<a;){const o=r[n++];l.push(o);for(let c=n+o*4;n<c;n+=4)l.push(r[n]),d.push(r[n+1]*i),d.push(r[n+2]*i),d.push(r[n+3])}s.bones=l,s.vertices=f.Utils.toFloatArray(d)}readAnimation(t,s,e){const i=this.scale,r=new Array;if(t.slots)for(const l in t.slots){const n=t.slots[l],a=e.findSlot(l);if(!a)throw new Error(`Slot not found: ${l}`);const o=a.index;for(const c in n){const m=n[c];if(!m)continue;const g=m.length;if(c=="attachment"){const u=new xt(g,o);for(let p=0;p<g;p++){const y=m[p];u.setFrame(p,I(y,"time",0),I(y,"name",null))}r.push(u)}else if(c=="rgba"){const u=new Qt(g,g<<2,o);let p=m[0],y=I(p,"time",0),S=f.Color.fromString(p.color);for(let x=0,k=0;;x++){u.setFrame(x,y,S.r,S.g,S.b,S.a);const w=m[x+1];if(!w){u.shrink(k);break}const M=I(w,"time",0),B=f.Color.fromString(w.color),A=p.curve;A&&(k=L(A,u,k,x,0,y,M,S.r,B.r,1),k=L(A,u,k,x,1,y,M,S.g,B.g,1),k=L(A,u,k,x,2,y,M,S.b,B.b,1),k=L(A,u,k,x,3,y,M,S.a,B.a,1)),y=M,S=B,p=w}r.push(u)}else if(c=="rgb"){const u=new Zt(g,g*3,o);let p=m[0],y=I(p,"time",0),S=f.Color.fromString(p.color);for(let x=0,k=0;;x++){u.setFrame(x,y,S.r,S.g,S.b);const w=m[x+1];if(!w){u.shrink(k);break}const M=I(w,"time",0),B=f.Color.fromString(w.color),A=p.curve;A&&(k=L(A,u,k,x,0,y,M,S.r,B.r,1),k=L(A,u,k,x,1,y,M,S.g,B.g,1),k=L(A,u,k,x,2,y,M,S.b,B.b,1)),y=M,S=B,p=w}r.push(u)}else if(c=="alpha")r.push(lt(m,new te(g,g,o),0,1));else if(c=="rgba2"){const u=new ee(g,g*7,o);let p=m[0],y=I(p,"time",0),S=f.Color.fromString(p.light),x=f.Color.fromString(p.dark);for(let k=0,w=0;;k++){u.setFrame(k,y,S.r,S.g,S.b,S.a,x.r,x.g,x.b);const M=m[k+1];if(!M){u.shrink(w);break}const B=I(M,"time",0),A=f.Color.fromString(M.light),Y=f.Color.fromString(M.dark),C=p.curve;C&&(w=L(C,u,w,k,0,y,B,S.r,A.r,1),w=L(C,u,w,k,1,y,B,S.g,A.g,1),w=L(C,u,w,k,2,y,B,S.b,A.b,1),w=L(C,u,w,k,3,y,B,S.a,A.a,1),w=L(C,u,w,k,4,y,B,x.r,Y.r,1),w=L(C,u,w,k,5,y,B,x.g,Y.g,1),w=L(C,u,w,k,6,y,B,x.b,Y.b,1)),y=B,S=A,x=Y,p=M}r.push(u)}else if(c=="rgb2"){const u=new ne(g,g*6,o);let p=m[0],y=I(p,"time",0),S=f.Color.fromString(p.light),x=f.Color.fromString(p.dark);for(let k=0,w=0;;k++){u.setFrame(k,y,S.r,S.g,S.b,x.r,x.g,x.b);const M=m[k+1];if(!M){u.shrink(w);break}const B=I(M,"time",0),A=f.Color.fromString(M.light),Y=f.Color.fromString(M.dark),C=p.curve;C&&(w=L(C,u,w,k,0,y,B,S.r,A.r,1),w=L(C,u,w,k,1,y,B,S.g,A.g,1),w=L(C,u,w,k,2,y,B,S.b,A.b,1),w=L(C,u,w,k,3,y,B,x.r,Y.r,1),w=L(C,u,w,k,4,y,B,x.g,Y.g,1),w=L(C,u,w,k,5,y,B,x.b,Y.b,1)),y=B,S=A,x=Y,p=M}r.push(u)}}}if(t.bones)for(const l in t.bones){const n=t.bones[l],a=e.findBone(l);if(!a)throw new Error(`Bone not found: ${l}`);const o=a.index;for(const c in n){const m=n[c],g=m.length;if(g!=0){if(c==="rotate")r.push(lt(m,new At(g,g,o),0,1));else if(c==="translate"){const u=new Wt(g,g<<1,o);r.push(Ae(m,u,"x","y",0,i))}else if(c==="translatex"){const u=new Ot(g,g,o);r.push(lt(m,u,0,i))}else if(c==="translatey"){const u=new zt(g,g,o);r.push(lt(m,u,0,i))}else if(c==="scale"){const u=new _t(g,g<<1,o);r.push(Ae(m,u,"x","y",1,1))}else if(c==="scalex"){const u=new jt(g,g,o);r.push(lt(m,u,1,1))}else if(c==="scaley"){const u=new Gt(g,g,o);r.push(lt(m,u,1,1))}else if(c==="shear"){const u=new Ht(g,g<<1,o);r.push(Ae(m,u,"x","y",0,1))}else if(c==="shearx"){const u=new Kt(g,g,o);r.push(lt(m,u,0,1))}else if(c==="sheary"){const u=new Jt(g,g,o);r.push(lt(m,u,0,1))}}}}if(t.ik)for(const l in t.ik){const n=t.ik[l];let a=n[0];if(!a)continue;const o=e.findIkConstraint(l);if(!o)throw new Error(`IK Constraint not found: ${l}`);const c=e.ikConstraints.indexOf(o),m=new ie(n.length,n.length<<1,c);let g=I(a,"time",0),u=I(a,"mix",1),p=I(a,"softness",0)*i;for(let y=0,S=0;;y++){m.setFrame(y,g,u,p,I(a,"bendPositive",!0)?1:-1,I(a,"compress",!1),I(a,"stretch",!1));const x=n[y+1];if(!x){m.shrink(S);break}const k=I(x,"time",0),w=I(x,"mix",1),M=I(x,"softness",0)*i,B=a.curve;B&&(S=L(B,m,S,y,0,g,k,u,w,1),S=L(B,m,S,y,1,g,k,p,M,i)),g=k,u=w,p=M,a=x}r.push(m)}if(t.transform)for(const l in t.transform){const n=t.transform[l];let a=n[0];if(!a)continue;const o=e.findTransformConstraint(l);if(!o)throw new Error(`Transform constraint not found: ${l}`);const c=e.transformConstraints.indexOf(o),m=new ae(n.length,n.length*6,c);let g=I(a,"time",0),u=I(a,"mixRotate",1),p=I(a,"mixX",1),y=I(a,"mixY",p),S=I(a,"mixScaleX",1),x=I(a,"mixScaleY",S);const k=I(a,"mixShearY",1);for(let w=0,M=0;;w++){m.setFrame(w,g,u,p,y,S,x,k);const B=n[w+1];if(!B){m.shrink(M);break}const A=I(B,"time",0),Y=I(B,"mixRotate",1),C=I(B,"mixX",1),b=I(B,"mixY",C),T=I(B,"mixScaleX",1),v=I(B,"mixScaleY",T),F=I(B,"mixShearY",1),E=a.curve;E&&(M=L(E,m,M,w,0,g,A,u,Y,1),M=L(E,m,M,w,1,g,A,p,C,1),M=L(E,m,M,w,2,g,A,y,b,1),M=L(E,m,M,w,3,g,A,S,T,1),M=L(E,m,M,w,4,g,A,x,v,1),M=L(E,m,M,w,5,g,A,k,F,1)),g=A,u=Y,p=C,y=b,S=T,x=v,S=T,a=B}r.push(m)}if(t.path)for(const l in t.path){const n=t.path[l],a=e.findPathConstraint(l);if(!a)throw new Error(`Path constraint not found: ${l}`);const o=e.pathConstraints.indexOf(a);for(const c in n){const m=n[c];let g=m[0];if(!g)continue;const u=m.length;if(c==="position"){const p=new re(u,u,o);r.push(lt(m,p,0,a.positionMode==f.PositionMode.Fixed?i:1))}else if(c==="spacing"){const p=new oe(u,u,o);r.push(lt(m,p,0,a.spacingMode==G.Length||a.spacingMode==G.Fixed?i:1))}else if(c==="mix"){const p=new le(u,u*3,o);let y=I(g,"time",0),S=I(g,"mixRotate",1),x=I(g,"mixX",1),k=I(g,"mixY",x);for(let w=0,M=0;;w++){p.setFrame(w,y,S,x,k);const B=m[w+1];if(!B){p.shrink(M);break}const A=I(B,"time",0),Y=I(B,"mixRotate",1),C=I(B,"mixX",1),b=I(B,"mixY",C),T=g.curve;T&&(M=L(T,p,M,w,0,y,A,S,Y,1),M=L(T,p,M,w,1,y,A,x,C,1),M=L(T,p,M,w,2,y,A,k,b,1)),y=A,S=Y,x=C,k=b,g=B}r.push(p)}}}if(t.deform){t.attachments={};for(const l in t.deform){const n=t.deform[l],a=t.attachments[l]={};for(const o in n){const c=n[o],m=a[o]={};for(const g in c)m[g]={deform:c[g]}}}}if(t.attachments)for(const l in t.attachments){const n=t.attachments[l],a=e.findSkin(l);if(a==null){if(f.settings.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${l}`);continue}for(const o in n){const c=n[o],m=e.findSlot(o);if(!m)throw new Error(`Slot not found: ${o}`);const g=m.index;for(const u in c){const p=c[u],y=a.getAttachment(g,u);for(const S in p){const x=p[S];let k=x[0];if(k){if(S=="deform"){const w=y.bones,M=y.vertices,B=w?M.length/3*2:M.length,A=new se(x.length,x.length,g,y);let Y=I(k,"time",0);for(let C=0,b=0;;C++){let T;const v=I(k,"vertices",null);if(!v)T=w?f.Utils.newFloatArray(B):M;else{T=f.Utils.newFloatArray(B);const D=I(k,"offset",0);if(f.Utils.arrayCopy(v,0,T,D,v.length),i!=1)for(let U=D,N=U+v.length;U<N;U++)T[U]*=i;if(!w)for(let U=0;U<B;U++)T[U]+=M[U]}A.setFrame(C,Y,T);const F=x[C+1];if(!F){A.shrink(b);break}const E=I(F,"time",0),V=k.curve;V&&(b=L(V,A,b,C,0,Y,E,0,1,1)),Y=E,k=F}r.push(A)}else if(S=="sequence"){const w=new Mt(x.length,g,y);let M=0;for(let B=0;B<x.length;B++){const A=I(k,"delay",M),Y=I(k,"time",0),C=rt[I(k,"mode","hold")],b=I(k,"index",0);w.setFrame(B,Y,C,b,A),M=A,k=x[B+1]}r.push(w)}}}}}}if(t.drawOrder){const l=new wt(t.drawOrder.length),n=e.slots.length;let a=0;for(let o=0;o<t.drawOrder.length;o++,a++){const c=t.drawOrder[o];let m=null;const g=I(c,"offsets",null);if(g){m=f.Utils.newArray(n,-1);const u=f.Utils.newArray(n-g.length,0);let p=0,y=0;for(let S=0;S<g.length;S++){const x=g[S],k=e.findSlot(x.slot);if(!k)throw new Error(`Slot not found: ${k}`);const w=k.index;for(;p!=w;)u[y++]=p++;m[p+x.offset]=p++}for(;p<n;)u[y++]=p++;for(let S=n-1;S>=0;S--)m[S]==-1&&(m[S]=u[--y])}l.setFrame(a,I(c,"time",0),m)}r.push(l)}if(t.events){const l=new It(t.events.length);let n=0;for(let a=0;a<t.events.length;a++,n++){const o=t.events[a],c=e.findEvent(o.name);if(!c)throw new Error(`Event not found: ${o.name}`);const m=new ue(f.Utils.toSinglePrecision(I(o,"time",0)),c);m.intValue=I(o,"int",c.intValue),m.floatValue=I(o,"float",c.floatValue),m.stringValue=I(o,"string",c.stringValue),m.data.audioPath&&(m.volume=I(o,"volume",1),m.balance=I(o,"balance",0)),l.setFrame(n,m)}r.push(l)}let d=0;for(let l=0,n=r.length;l<n;l++)d=Math.max(d,r[l].getDuration());if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new Et(s,r,d))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return at.BLEND_MODES.NORMAL;if(t=="additive")return at.BLEND_MODES.ADD;if(t=="multiply")return at.BLEND_MODES.MULTIPLY;if(t=="screen")return at.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class Bn{constructor(t,s,e,i,r){this.mesh=t,this.skin=s,this.slotIndex=e,this.parent=i,this.inheritTimeline=r}}function lt(h,t,s,e){let i=h[0],r=I(i,"time",0),d=I(i,"value",s)*e,l=0;for(let n=0;;n++){t.setFrame(n,r,d);const a=h[n+1];if(!a)return t.shrink(l),t;const o=I(a,"time",0),c=I(a,"value",s)*e;i.curve&&(l=L(i.curve,t,l,n,0,r,o,d,c,e)),r=o,d=c,i=a}}function Ae(h,t,s,e,i,r){let d=h[0],l=I(d,"time",0),n=I(d,s,i)*r,a=I(d,e,i)*r,o=0;for(let c=0;;c++){t.setFrame(c,l,n,a);const m=h[c+1];if(!m)return t.shrink(o),t;const g=I(m,"time",0),u=I(m,s,i)*r,p=I(m,e,i)*r,y=d.curve;y&&(o=L(y,t,o,c,0,l,g,n,u,r),o=L(y,t,o,c,1,l,g,a,p,r)),l=g,n=u,a=p,d=m}}function L(h,t,s,e,i,r,d,l,n,a){if(h=="stepped")return t.setStepped(e),s;const o=i<<2,c=h[o],m=h[o+1]*a,g=h[o+2],u=h[o+3]*a;return t.setBezier(s,e,i,r,l,c,m,g,u,d,n),s+1}function I(h,t,s){return h[t]!==void 0?h[t]:s}class An extends f.SpineBase{createSkeleton(t){this.skeleton=new xe(t),this.skeleton.updateWorldTransform(),this.stateData=new De(t),this.state=new yt(this.stateData)}}return X.AlphaTimeline=te,X.Animation=Et,X.AnimationState=yt,X.AnimationStateAdapter=He,X.AnimationStateData=De,X.AtlasAttachmentLoader=Qe,X.Attachment=Lt,X.AttachmentTimeline=xt,X.Bone=de,X.BoneData=me,X.BoundingBoxAttachment=bt,X.ClippingAttachment=Tt,X.ConstraintData=Rt,X.CurveTimeline=tt,X.CurveTimeline1=et,X.CurveTimeline2=Ut,X.DeformTimeline=se,X.DrawOrderTimeline=wt,X.Event=ue,X.EventData=fe,X.EventQueue=Xe,X.EventTimeline=It,X.EventType=K,X.IkConstraint=Re,X.IkConstraintData=ge,X.IkConstraintTimeline=ie,X.MeshAttachment=gt,X.PathAttachment=pt,X.PathConstraint=kt,X.PathConstraintData=pe,X.PathConstraintMixTimeline=le,X.PathConstraintPositionTimeline=re,X.PathConstraintSpacingTimeline=oe,X.PointAttachment=vt,X.RGB2Timeline=ne,X.RGBA2Timeline=ee,X.RGBATimeline=Qt,X.RGBTimeline=Zt,X.RegionAttachment=q,X.RotateTimeline=At,X.ScaleTimeline=_t,X.ScaleXTimeline=jt,X.ScaleYTimeline=Gt,X.Sequence=Ft,X.SequenceMode=rt,X.SequenceModeValues=Nt,X.SequenceTimeline=Mt,X.ShearTimeline=Ht,X.ShearXTimeline=Kt,X.ShearYTimeline=Jt,X.Skeleton=xe,X.SkeletonBinary=$e,X.SkeletonBounds=Sn,X.SkeletonData=we,X.SkeletonJson=Be,X.Skin=Pt,X.SkinEntry=ke,X.Slot=Pe,X.SlotData=Me,X.SpacingMode=G,X.Spine=An,X.Timeline=j,X.TrackEntry=Dt,X.TransformConstraint=Ve,X.TransformConstraintData=ye,X.TransformConstraintTimeline=ae,X.TranslateTimeline=Wt,X.TranslateXTimeline=Ot,X.TranslateYTimeline=zt,X.VertexAttachment=Z,X}({},PIXI.spine,PIXI);
//# sourceMappingURL=runtime-4.1.js.map
